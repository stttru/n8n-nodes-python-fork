/*
 * Copyright (c) 2024 naskio (Original Author)
 * Copyright (c) 2025 Sergei Trufanov (Fork Author)
 * 
 * This file has been modified from the original n8n-nodes-python project.
 * Original project: https://github.com/naskio/n8n-nodes-python
 * 
 * Licensed under the Apache License, Version 2.0 with Commons Clause.
 * See LICENSE.md file for details.
 * 
 * üö® CRITICAL WARNING: 100% OF MODIFICATIONS GENERATED BY AI üö®
 * ALL modifications and new features (100%) were developed with AI assistance.
 * This code may contain CRITICAL ERRORS, security vulnerabilities, or
 * unexpected behavior. USE AT YOUR OWN RISK. Thorough testing required.
 * 
 * This software is provided for personal, non-commercial use only.
 * The maintainer assumes no responsibility for any use by third parties.
 */

import {IExecuteFunctions, ILoadOptionsFunctions} from 'n8n-core';
import {
	IDataObject,
	INodeExecutionData,
	INodePropertyOptions,
	INodeType,
	INodeTypeDescription,
	NodeOperationError,
} from 'n8n-workflow';
import {spawn} from 'child_process';
import * as fs from 'fs';
import * as path from 'path';
import * as tempy from 'tempy';

// –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤–µ—Ä—Å–∏—é npm –≤ —á–∏—Å–ª–æ–≤—É—é –≤–µ—Ä—Å–∏—é –¥–ª—è n8n (–Ω–∞–ø—Ä–∏–º–µ—Ä, "1.14.1" -> 14)
function getPackageVersion(): string {
	try {
		let packageJson: any;
		try {
			// –î–ª—è compiled –≤–µ—Ä—Å–∏–∏ (dist/nodes/PythonFunction/ -> –∫–æ—Ä–µ–Ω—å –ø–∞–∫–µ—Ç–∞)
			packageJson = require('../../../package.json');
		} catch (e1) {
			try {
				// –î–ª—è dev –≤–µ—Ä—Å–∏–∏ (nodes/PythonFunction/ -> –∫–æ—Ä–µ–Ω—å –ø—Ä–æ–µ–∫—Ç–∞)
				packageJson = require('../../package.json');
			} catch (e2) {
				return 'unknown';
			}
		}
		return packageJson.version || 'unknown';
	} catch (error) {
		return 'unknown';
	}
}

function getNodeVersionFromPackage(): number {
	try {
		// –ü—Ä–æ–±—É–µ–º –Ω–µ—Å–∫–æ–ª—å–∫–æ –ø—É—Ç–µ–π –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏ dev/compiled –æ–∫—Ä—É–∂–µ–Ω–∏–π
		let packageJson: { version: string };
		try {
			// –î–ª—è compiled –≤–µ—Ä—Å–∏–∏ (dist/nodes/PythonFunction/ -> –∫–æ—Ä–µ–Ω—å –ø–∞–∫–µ—Ç–∞)
			packageJson = require('../../../package.json');
		} catch (e1) {
			try {
				// –î–ª—è dev –≤–µ—Ä—Å–∏–∏ (nodes/PythonFunction/ -> –∫–æ—Ä–µ–Ω—å –ø—Ä–æ–µ–∫—Ç–∞)
				packageJson = require('../../package.json');
			} catch (e2) {
				// Fallback - –∏—Å–ø–æ–ª—å–∑—É–µ–º –≤–µ—Ä—Å–∏—é –∏–∑ dist
				console.warn('Could not load package.json dynamically, using fallback version');
				return 14; // –≤–µ—Ä—Å–∏—è 1.14.x -> 14
			}
		}
		
		const version = packageJson.version; // –Ω–∞–ø—Ä–∏–º–µ—Ä, "1.14.1"
		const versionParts = version.split('.');
		// –ò—Å–ø–æ–ª—å–∑—É–µ–º –≤—Ç–æ—Ä—É—é —á–∞—Å—Ç—å –≤–µ—Ä—Å–∏–∏ –∫–∞–∫ –≤–µ—Ä—Å–∏—é –Ω–æ–¥—ã (14 –∏–∑ "1.14.1")
		// –≠—Ç–æ –ø–æ–∑–≤–æ–ª–∏—Ç –æ—Ç—Å–ª–µ–∂–∏–≤–∞—Ç—å –∏–∑–º–µ–Ω–µ–Ω–∏—è –≤ –º–∏–Ω–æ—Ä–Ω—ã—Ö –≤–µ—Ä—Å–∏—è—Ö
		return parseInt(versionParts[1], 10) || 1;
	} catch (error) {
		console.warn('Failed to read package version, using fallback version 14');
		return 14;
	}
}


export interface IExecReturnData {
	exitCode: number;
	error?: Error;
	stderr: string;
	stdout: string;
}

interface BinaryFileInfo {
	key: string;
	data: {
		data: string;
		fileName: string;
		mimeType: string;
		fileExtension?: string;
	};
	itemIndex: number;
}

interface FileMapping {
	filename: string;
	mimetype: string;
	size: number;
	tempPath?: string;
	base64Data?: string;
	binaryKey: string;
	itemIndex: number;
	extension: string;
}

interface FileProcessingOptions {
	enabled: boolean;
	accessMethod: 'temp_files' | 'base64' | 'both';
	maxFileSize: number;
	includeMetadata: boolean;
	autoCleanup: boolean;
}

interface OutputFileProcessingOptions {
	enabled: boolean;
	maxOutputFileSize: number;
	autoCleanupOutput: boolean;
	includeOutputMetadata: boolean;
	autoInterceptFiles?: boolean;
	expectedFileName?: string;
	fileDetectionMode?: 'variable_path' | 'auto_search';
}

interface OutputFileInfo {
	filename: string;
	size: number;
	mimetype: string;
	extension: string;
	base64Data: string;
	binaryKey: string;
}

// Code Template interfaces for Extract Code Template functionality
interface CodeTemplateData {
	autoGeneratedCode: string;
	templateGenerated: boolean;
	generationTimestamp: string;
	templateInfo: {
		hasInputItems: boolean;
		hasEnvVars: boolean;
		hasCredentials: boolean;
		hasInputFiles: boolean;
		hasOutputDir: boolean;
	};
}

// File debugging interfaces
interface FileDebugOptions {
	enabled: boolean;
	includeInputFileDebug: boolean;
	includeOutputFileDebug: boolean;
	includeSystemInfo: boolean;
	includeDirectoryListing: boolean;
}

interface FileDebugInfo {
	input_files?: {
		count: number;
		total_size_mb: number;
		files_by_type: Record<string, number>;
		files_details: Array<{
			filename: string;
			size_mb: number;
			mimetype: string;
			extension: string;
			binary_key: string;
			item_index: number;
			temp_path?: string;
			base64_available: boolean;
		}>;
		processing_errors?: string[];
	};
	output_files?: {
		processing_enabled: boolean;
		output_directory: string;
		directory_exists: boolean;
		directory_writable: boolean;
		directory_permissions?: string;
		found_files: Array<{
			filename: string;
			size_mb: number;
			mimetype: string;
			extension: string;
			full_path: string;
			created_at: string;
		}>;
		scan_errors?: string[];
	};
	system_info?: {
		python_executable: string;
		working_directory: string;
		user_permissions: {
			can_write_temp: boolean;
			can_create_files: boolean;
		};
		disk_space: {
			available_mb?: number;
			temp_dir?: string;
		};
		environment_variables: {
			output_dir_available: boolean;
			output_dir_value?: string;
		};
	};
	directory_listing?: {
		temp_directory?: string[];
		output_directory?: string[];
		working_directory?: string[];
	};
}


async function cleanupScript(scriptPath: string): Promise<void> {
	try {
		if (fs.existsSync(scriptPath)) {
			fs.unlinkSync(scriptPath);
			console.log(`Cleaned up script: ${scriptPath}`);
		}
	} catch (error) {
		console.warn(`Failed to cleanup script ${scriptPath}:`, error);
		// Don't throw error - cleanup should not break main process
	}
}

function createExecutionDirectory(): string {
	const timestamp = Date.now();
	const randomId = Math.random().toString(36).substring(2, 8);
	const uniqueId = `n8n_python_exec_${timestamp}_${randomId}`;
	const execDir = path.join(require('os').tmpdir(), uniqueId);
	
	fs.mkdirSync(execDir, { recursive: true });
	console.log(`Created execution directory: ${execDir}`);
	
	return execDir;
}

async function cleanupExecutionDirectory(execDir: string): Promise<void> {
	if (!fs.existsSync(execDir)) {
		return;
	}
	
	try {
		// Recursively remove all files and subdirectories
		const removeRecursive = (dirPath: string) => {
			if (fs.existsSync(dirPath)) {
				fs.readdirSync(dirPath).forEach((file) => {
					const curPath = path.join(dirPath, file);
					if (fs.lstatSync(curPath).isDirectory()) {
						removeRecursive(curPath);
					} else {
						fs.unlinkSync(curPath);
					}
				});
				fs.rmdirSync(dirPath);
			}
		};
		
		removeRecursive(execDir);
		console.log(`Completely removed execution directory: ${execDir}`);
	} catch (error) {
		console.warn(`Failed to cleanup execution directory ${execDir}:`, error);
	}
}

// File processing functions
function detectBinaryFiles(items: INodeExecutionData[]): BinaryFileInfo[] {
	const binaryFiles: BinaryFileInfo[] = [];
	
	for (let itemIndex = 0; itemIndex < items.length; itemIndex++) {
		const item = items[itemIndex];
		if (item.binary) {
			for (const [key, binaryData] of Object.entries(item.binary)) {
				if (binaryData && binaryData.data && binaryData.fileName) {
					binaryFiles.push({
						key,
						data: {
							data: binaryData.data,
							fileName: binaryData.fileName,
							mimeType: binaryData.mimeType || 'application/octet-stream',
							fileExtension: binaryData.fileExtension,
						},
						itemIndex,
					});
				}
			}
		}
	}
	
	return binaryFiles;
}

function validateFile(binaryFile: BinaryFileInfo, options: FileProcessingOptions): void {
	// Check file size
	const buffer = Buffer.from(binaryFile.data.data, 'base64');
	const sizeInMB = buffer.length / (1024 * 1024);
	
	if (sizeInMB > options.maxFileSize) {
		throw new Error(`File "${binaryFile.data.fileName}" is too large: ${sizeInMB.toFixed(2)}MB > ${options.maxFileSize}MB`);
	}
	
	console.log(`File "${binaryFile.data.fileName}" validated: ${sizeInMB.toFixed(2)}MB, type: ${binaryFile.data.mimeType}`);
}

function getFileExtension(filename: string): string {
	const extension = path.extname(filename).toLowerCase();
	return extension.startsWith('.') ? extension.substring(1) : extension;
}

function sanitizeFileName(filename: string): string {
	// Remove or replace dangerous characters
	return filename.replace(/[<>:"/\\|?*\x00-\x1f]/g, '_').substring(0, 255);
}

async function createTemporaryFiles(binaryFiles: BinaryFileInfo[], options: FileProcessingOptions): Promise<FileMapping[]> {
	const fileMappings: FileMapping[] = [];
	
	for (const binaryFile of binaryFiles) {
		try {
			// Validate file first
			validateFile(binaryFile, options);
			
			const buffer = Buffer.from(binaryFile.data.data, 'base64');
			const extension = getFileExtension(binaryFile.data.fileName);
			const sanitizedFileName = sanitizeFileName(binaryFile.data.fileName);
			
			const fileMapping: FileMapping = {
				filename: binaryFile.data.fileName,
				mimetype: binaryFile.data.mimeType,
				size: buffer.length,
				binaryKey: binaryFile.key,
				itemIndex: binaryFile.itemIndex,
				extension,
			};
			
			// Add base64 data if requested
			if (options.accessMethod === 'base64' || options.accessMethod === 'both') {
				fileMapping.base64Data = binaryFile.data.data;
			}
			
			// Create temporary file if requested
			if (options.accessMethod === 'temp_files' || options.accessMethod === 'both') {
				const tempPath = tempy.file({ 
					extension: extension || 'bin',
				});
				
				// Write the base64 data directly as binary
				await fs.promises.writeFile(tempPath, binaryFile.data.data, 'base64');
				fileMapping.tempPath = tempPath;
				
				console.log(`Created temporary file: ${tempPath} (${(buffer.length / 1024).toFixed(1)}KB)`);
			}
			
			fileMappings.push(fileMapping);
			
		} catch (error) {
			console.error(`Failed to process file "${binaryFile.data.fileName}":`, error);
			throw new Error(`File processing failed for "${binaryFile.data.fileName}": ${(error as Error).message}`);
		}
	}
	
	return fileMappings;
}

async function cleanupTemporaryFiles(fileMappings: FileMapping[]): Promise<void> {
	let cleanedCount = 0;
	let errorCount = 0;
	
	for (const fileMapping of fileMappings) {
		if (fileMapping.tempPath) {
			try {
				if (fs.existsSync(fileMapping.tempPath)) {
					await fs.promises.unlink(fileMapping.tempPath);
					cleanedCount++;
				}
			} catch (error) {
				errorCount++;
				console.warn(`Failed to cleanup temporary file: ${fileMapping.tempPath}`, error);
				// Don't throw - cleanup should not break main process
			}
		}
	}
	
	if (cleanedCount > 0) {
		console.log(`Cleaned up ${cleanedCount} temporary files`);
	}
	if (errorCount > 0) {
		console.warn(`Failed to cleanup ${errorCount} temporary files`);
	}
}


// –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤–µ—Ä—Å–∏—é npm –≤ —á–∏—Å–ª–æ–≤—É—é –≤–µ—Ä—Å–∏—é –¥–ª—è n8n (–Ω–∞–ø—Ä–∏–º–µ—Ä, "1.14.1" -> 14)

// Full Debug+ Diagnostics Interfaces
interface SystemDiagnostics {
	os: {
		platform: string;
		release: string;
		arch: string;
		type: string;
		hostname: string;
		uptime_seconds: number;
		total_memory_mb: number;
		free_memory_mb: number;
		cpus_count: number;
		cpus_model: string;
	};
	nodejs: {
		version: string;
		v8_version: string;
		arch: string;
		platform: string;
		process_id: number;
		parent_process_id: number;
		executable_path: string;
		cwd: string;
		uptime_seconds: number;
		memory_usage_mb: {
			rss: number;
			heap_total: number;
			heap_used: number;
			external: number;
		};
	};
	n8n: {
		version: string;
		execution_mode: string;
		workflow_id: string;
		execution_id: string;
		node_env: string;
		config_dir: string;
	};
	python: {
		executable: string;
		version_command: string;
		version_output: string;
		path_resolved: string;
		is_found: boolean;
		version_details: {
			full_version: string;
			major: number;
			minor: number;
			micro: number;
		} | null;
		installed_packages: {
			package_count: number;
			packages_list: string[];  // Top 50 packages for preview
			pip_freeze_command: string;
			pip_freeze_successful: boolean;
			pip_freeze_error: string | null;
		} | null;
	};
}

interface NodeInstallationDiagnostics {
	package: {
		name: string;
		version: string;
		description: string;
	};
	node: {
		type: string;
		name: string;
		version: number;
		subtitle: string;
		credentials_available: string[];
		parameters_count: number;
		outputs_count: number;
	};
	installation: {
		loaded_from: string;
		file_path: string;
	};
}

interface DataSourcesDiagnostics {
	input_variables: {
		enabled: boolean;
		items_received: number;
		items_have_data: boolean;
		first_item_keys: string[];
		first_item_structure: Record<string, string>;
		all_items_sizes: number[];
		total_data_kb: number;
	};
	credentials: {
		enabled: boolean;
		credential_type: string;
		credential_connected: boolean;
		credential_id: string;
		credential_name: string;
		raw_credential_data_keys: string[];
		envFileContent_exists: boolean;
		envFileContent_length: number;
		envFileContent_lines_count: number;
		envFileContent_preview_first_3_lines: string[];
		parsing_attempted: boolean;
		parsing_successful: boolean;
		parse_error: string | null;
		variables_parsed: number;
		variable_names: string[];
		variable_types: Record<string, string>;
	};
	system_environment: {
		enabled: boolean;
		total_env_vars_available: number;
		requested_vars: string[];
		found_vars: string[];
		missing_vars: string[];
		found_values_preview: Record<string, string>;
		all_process_env_keys: string[];
	};
}

interface ScriptGenerationDiagnostics {
	user_code: {
		provided: boolean;
		length_chars: number;
		lines_count: number;
		has_imports: boolean;
		has_future_imports: boolean;
	};
	template: {
		sections_generated: string[];
		individual_vars_count: number;
		env_vars_count: number;
		reserved_vars_defined: string[];
		input_files_count: number;
		output_dir_provided: boolean;
	};
	final_script: {
		total_length_chars: number;
		total_lines_count: number;
		header_length: number;
		user_code_length: number;
		estimated_size_kb: number;
	};
	full_assembled_script: string;  // Complete script with all data substitutions
}

interface ExecutionDiagnostics {
	preparation: {
		temp_dir_created: string;
		script_file_path: string;
		script_file_size_bytes: number;
		script_written_successfully: boolean;
	};
	command: {
		executable: string;
		full_command: string;
		arguments: string[];
		working_directory: string;
		timeout_minutes: number;
	};
	timing: {
		preparation_started: string;
		script_created: string;
		execution_started: string;
		execution_finished: string;
		preparation_duration_ms: number;
		execution_duration_ms: number;
		total_duration_ms: number;
	};
	result: {
		exit_code: number;
		stdout_length: number;
		stderr_length: number;
		timed_out: boolean;
		killed: boolean;
		signal: string | null;
	};
	cleanup: {
		attempted: boolean;
		successful: boolean;
		files_removed: string[];
		error: string | null;
	};
}

interface FullDebugPlusDiagnostics {
	mode: string;
	timestamp_start: string;
	timestamp_end: string;
	total_duration_ms: number;
	
	system: SystemDiagnostics;
	node_installation: NodeInstallationDiagnostics;
	data_sources: DataSourcesDiagnostics;
	script_generation: ScriptGenerationDiagnostics;
	execution: ExecutionDiagnostics;
	
	errors_and_warnings: {
		errors: string[];
		warnings: string[];
	};
	
	troubleshooting_hints: string[];
	
	final_summary: {
		data_sources_loaded: string[];
		total_variables_injected: number;
		script_executed: boolean;
		execution_successful: boolean;
		output_branch: string;
	};
}

function createFullDebugPlusDiagnostics(): FullDebugPlusDiagnostics {
	const os = require('os');
	
	return {
		mode: 'full_plus',
		timestamp_start: new Date().toISOString(),
		timestamp_end: '',
		total_duration_ms: 0,
		
		system: {
			os: {
				platform: os.platform(),
				release: os.release(),
				arch: os.arch(),
				type: os.type(),
				hostname: os.hostname(),
				uptime_seconds: os.uptime(),
				total_memory_mb: Math.round(os.totalmem() / 1024 / 1024),
				free_memory_mb: Math.round(os.freemem() / 1024 / 1024),
				cpus_count: os.cpus().length,
				cpus_model: os.cpus()[0]?.model || 'unknown',
			},
			nodejs: {
				version: process.version,
				v8_version: process.versions.v8,
				arch: process.arch,
				platform: process.platform,
				process_id: process.pid,
				parent_process_id: process.ppid,
				executable_path: process.execPath,
				cwd: process.cwd(),
				uptime_seconds: Math.round(process.uptime()),
				memory_usage_mb: {
					rss: Math.round(process.memoryUsage().rss / 1024 / 1024),
					heap_total: Math.round(process.memoryUsage().heapTotal / 1024 / 1024),
					heap_used: Math.round(process.memoryUsage().heapUsed / 1024 / 1024),
					external: Math.round(process.memoryUsage().external / 1024 / 1024),
				},
			},
			n8n: {
				version: process.env.N8N_VERSION || 'unknown',
				execution_mode: process.env.EXECUTIONS_MODE || 'regular',
				workflow_id: '',
				execution_id: '',
				node_env: process.env.NODE_ENV || 'production',
				config_dir: process.env.N8N_USER_FOLDER || 'default',
			},
			python: {
				executable: '',
				version_command: '',
				version_output: '',
				path_resolved: '',
				is_found: false,
				version_details: null,
				installed_packages: null,
			},
		},
		
		node_installation: {
			package: {
				name: '',
				version: '',
				description: '',
			},
			node: {
				type: '',
				name: '',
				version: 0,
				subtitle: '',
				credentials_available: [],
				parameters_count: 0,
				outputs_count: 0,
			},
			installation: {
				loaded_from: '',
				file_path: '',
			},
		},
		
		data_sources: {
			input_variables: {
				enabled: false,
				items_received: 0,
				items_have_data: false,
				first_item_keys: [],
				first_item_structure: {},
				all_items_sizes: [],
				total_data_kb: 0,
			},
			credentials: {
				enabled: false,
				credential_type: 'pythonEnvVars',
				credential_connected: false,
				credential_id: '',
				credential_name: '',
				raw_credential_data_keys: [],
				envFileContent_exists: false,
				envFileContent_length: 0,
				envFileContent_lines_count: 0,
				envFileContent_preview_first_3_lines: [],
				parsing_attempted: false,
				parsing_successful: false,
				parse_error: null,
				variables_parsed: 0,
				variable_names: [],
				variable_types: {},
			},
			system_environment: {
				enabled: false,
				total_env_vars_available: Object.keys(process.env).length,
				requested_vars: [],
				found_vars: [],
				missing_vars: [],
				found_values_preview: {},
				all_process_env_keys: Object.keys(process.env).slice(0, 50), // First 50 for preview
			},
		},
		
		script_generation: {
			user_code: {
				provided: false,
				length_chars: 0,
				lines_count: 0,
				has_imports: false,
				has_future_imports: false,
			},
			template: {
				sections_generated: [],
				individual_vars_count: 0,
				env_vars_count: 0,
				reserved_vars_defined: [],
				input_files_count: 0,
				output_dir_provided: false,
			},
			final_script: {
				total_length_chars: 0,
				total_lines_count: 0,
				header_length: 0,
				user_code_length: 0,
				estimated_size_kb: 0,
			},
			full_assembled_script: '',  // Will be populated during execution
		},
		
		execution: {
			preparation: {
				temp_dir_created: '',
				script_file_path: '',
				script_file_size_bytes: 0,
				script_written_successfully: false,
			},
			command: {
				executable: '',
				full_command: '',
				arguments: [],
				working_directory: '',
				timeout_minutes: 0,
			},
			timing: {
				preparation_started: '',
				script_created: '',
				execution_started: '',
				execution_finished: '',
				preparation_duration_ms: 0,
				execution_duration_ms: 0,
				total_duration_ms: 0,
			},
			result: {
				exit_code: -1,
				stdout_length: 0,
				stderr_length: 0,
				timed_out: false,
				killed: false,
				signal: null,
			},
			cleanup: {
				attempted: false,
				successful: false,
				files_removed: [],
				error: null,
			},
		},
		
		errors_and_warnings: {
			errors: [],
			warnings: [],
		},
		
		troubleshooting_hints: [],
		
		final_summary: {
			data_sources_loaded: [],
			total_variables_injected: 0,
			script_executed: false,
			execution_successful: false,
			output_branch: 'unknown',
		},
	};
}

export class PythonFunction implements INodeType {
	description: INodeTypeDescription = {
		displayName: 'Python Raw',
		name: 'pythonFunctionRaw',
		icon: 'file:python-logo.png',
		group: ['transform'],
		version: getNodeVersionFromPackage(),
		description: 'Run custom Python script once and return raw output (exitCode, stdout, stderr)',
		defaults: {
			name: 'Python Raw',
			color: '#4B8BBE',
		},
		inputs: ['main'],
		outputs: ['main', 'main'],
		outputNames: ['‚úì Success (exitCode=0)', '‚úó Error (exitCode‚â†0)'],
		credentials: [
			{
				name: 'pythonEnvVars',
				required: false,
			},
		],
		properties: [
			{
				displayName: 'Include Input Variables',
				name: 'includeInputVariables',
				type: 'boolean',
				default: true,
				description: 'Include input data from previous nodes. Creates individual variables from first input item (title, duration, author, etc.) and input_items array with all items.',
			},
			{
				displayName: 'Include Credential Variables',
				name: 'includeCredentialVars',
				type: 'boolean',
				default: false,
				description: 'Include variables from selected credential below. Creates env_vars dictionary and individual variables from credential data.',
			},
			{
				displayName: 'Include System Environment',
				name: 'includeSystemEnv',
				type: 'boolean',
				default: false,
				description: 'Include n8n process environment variables (PATH, HOME, NODE_ENV, etc.). Variables are added to env_vars dictionary.',
			},
			{
				displayName: 'System Environment Variables',
				name: 'systemEnvVars',
				type: 'string',
				default: '',
				placeholder: 'PATH,HOME,NODE_ENV',
				description: 'Comma-separated list of environment variable names to include when "Include System Environment" is enabled',
				displayOptions: {
					show: {
						includeSystemEnv: [true],
					},
				},
			},
			{
				displayName: 'Python Code',
				name: 'functionCode',
				typeOptions: {
					alwaysOpenEditWindow: true,
					rows: 20,
					editorLanguage: 'python',
				},
				type: 'string',
				default: `# Example: Configure data sources in "Data Sources Configuration" section above
# This example shows what's available when all sources are enabled

import json
import sys

# === INPUT DATA (if "Inject Input Variables" enabled) ===
# Individual variables from first input item:
# title, duration, author, etc.

# input_items array (always available, empty if disabled):
if input_items:
print("Input items count:", len(input_items))
else:
    print("No input items (option disabled or no data)")

# === ENVIRONMENT VARIABLES (if "Include Credential Variables" enabled) ===
# Individual variables from credentials:
# API_KEY, DB_HOST, TOKEN, etc.

# env_vars dictionary (always available, empty if no credentials):
if env_vars:
print("Available environment variables:")
print(json.dumps(env_vars, indent=2))
else:
    print("No environment variables (no credentials)")

# === SYSTEM ENVIRONMENT (if "Include System Environment Variables" enabled) ===
# PATH, HOME, NODE_ENV, etc. (added to env_vars dictionary)

# === BINARY FILES (if "File Processing" enabled) ===
if input_files:
    print(f"Found {len(input_files)} input files")
    for file_info in input_files:
        print(f"File: {file_info['filename']} ({file_info['size']} bytes)")

# === OUTPUT FILES (if "Output File Processing" enabled) ===
if output_dir:
    print(f"Output directory: {output_dir}")
    # Create files in output_dir - they'll be automatically included in n8n output

# Example: Access specific environment variable
# if env_vars:
#     api_key = env_vars.get('API_KEY')

# Example: Process input data
# if input_items:
#     for item in input_items:
#         print(f"Processing: {item.get('title', 'No title')}")

# Example: Generate output file
# if output_dir:
#     import os
#     with open(os.path.join(output_dir, 'result.txt'), 'w') as f:
#         f.write("Processing completed!")`,
				description: 'Python script to execute. Configure data sources in "Data Sources Configuration" section above.',
				noDataExpression: true,
			},
			{
				displayName: 'Hide Variable Values',
				name: 'hideVariableValues',
				type: 'boolean',
				default: false,
				description: 'Replace variable values with asterisks in generated scripts (for security)',
			},
			{
				displayName: 'Python Executable',
				name: 'pythonPath',
				type: 'string',
				default: 'python3',
				description: 'Path to Python executable (python3, python, or full path)',
			},
			{
				displayName: 'Execution Timeout (minutes)',
				name: 'executionTimeout',
				type: 'number',
				default: 10,
				required: true,
				description: 'Maximum time in minutes to allow script execution before forcefully terminating it',
				typeOptions: {
					minValue: 1,
					maxValue: 1440, // 24 hours max
				},
			},
			{
				displayName: 'Error Handling',
				name: 'errorHandling',
				type: 'options',
				options: [
					{
						name: 'Return Error Details',
						value: 'details',
						description: 'Continue execution and return error information as output data (default behavior)',
					},
					{
						name: 'Throw Error on Non-Zero Exit',
						value: 'throw',
						description: 'Stop workflow execution if script exits with non-zero code or system error occurs',
					},
					{
						name: 'Ignore Exit Code',
						value: 'ignore',
						description: 'Continue execution regardless of exit code, only throw on system errors',
					},
				],
				default: 'details',
				description: 'How to handle Python script errors and non-zero exit codes',
			},
			{
				displayName: 'Debug/Test Mode',
				name: 'debugMode',
				type: 'options',
				options: [
					{
						name: 'Off',
						value: 'off',
						description: 'Normal execution without debug information (default)',
					},
					{
						name: 'Basic Debug',
						value: 'basic',
						description: 'Add script content and basic execution info to output',
					},
					{
						name: 'Full Debug',
						value: 'full',
						description: 'Add script content, metadata, timing, and detailed execution info',
					},
					{
						name: 'üî¨ Full Debug+ (Developer Mode)',
						value: 'full_plus',
						description: 'MAXIMUM diagnostics: system info, node installation, environment, all data sources, execution details, file system - everything for troubleshooting',
					},
					{
						name: 'Test Only',
						value: 'test',
						description: 'Validate script and show preview without executing (safe testing)',
					},
					{
						name: 'Export Script',
						value: 'export',
						description: 'Full debug information plus script file as binary attachment',
					},
				],
				default: 'off',
				description: 'Choose debug and testing options for script development and troubleshooting',
			},
			{
				displayName: 'Script Export Format',
				name: 'scriptExportFormat',
				type: 'options',
				displayOptions: {
					show: {
						debugMode: ['export'],
					},
				},
				options: [
					{
						name: 'Python File (.py)',
						value: 'py',
						description: 'Export as .py file (standard Python script format)',
					},
					{
						name: 'Text File (.txt)',
						value: 'txt',
						description: 'Export as .txt file (useful when .py files are blocked by security policies)',
					},
				],
				default: 'py',
				description: 'Choose the file format for script export in debug mode',
			},
			{
				displayName: 'Script Generation Options',
				name: 'scriptOptions',
				type: 'collection',
				default: {},
				placeholder: 'Add Option',
				options: [
					{
						displayName: 'Include input_items Array',
						name: 'includeInputItems',
						type: 'boolean',
						default: true,
						description: 'Include input_items array in script (for accessing input data from previous nodes)',
					},
					{
						displayName: 'Include env_vars Dictionary',
						name: 'includeEnvVarsDict',
						type: 'boolean',
						default: false,
						description: 'Include env_vars dictionary in script (for legacy compatibility - variables are already available individually)',
					},
					{
						displayName: 'System Environment Variables',
						name: 'systemEnvVars',
						type: 'multiOptions',
						default: [],
						description: 'Select system environment variables to include in the script',
						options: [],
						typeOptions: {
							loadOptionsMethod: 'getSystemEnvVars',
						},
					},
				],
			},
			{
				displayName: 'File Processing',
				name: 'fileProcessing',
				type: 'collection',
				default: {},
				placeholder: 'Add File Options',
				description: 'Configure processing of binary files from previous nodes',
				options: [
					{
						displayName: 'Enable File Processing',
						name: 'enabled',
						type: 'boolean',
						default: false,
						description: 'Automatically extract binary files from input and make them available in Python script',
					},
					{
						displayName: 'File Access Method',
						name: 'accessMethod',
						type: 'options',
						options: [
							{
								name: 'Temporary Files (Recommended)',
								value: 'temp_files',
								description: 'Save files to temporary paths accessible in script',
							},
							{
								name: 'Base64 Content',
								value: 'base64',
								description: 'Provide file content as base64 strings',
							},
							{
								name: 'Both Methods',
								value: 'both',
								description: 'Provide both temporary file paths and base64 content',
							},
						],
						default: 'temp_files',
						description: 'How to provide file access in the Python script',
						displayOptions: {
							show: {
								enabled: [true],
							},
						},
					},
					{
						displayName: 'Max File Size (MB)',
						name: 'maxFileSize',
						type: 'number',
						typeOptions: {
							minValue: 1,
							maxValue: 1000,
						},
						default: 100,
						description: 'Maximum file size to process (1-1000 MB)',
						displayOptions: {
							show: {
								enabled: [true],
							},
						},
					},
					{
						displayName: 'Include File Metadata',
						name: 'includeMetadata',
						type: 'boolean',
						default: true,
						description: 'Include file metadata (size, mimetype, etc.) in script variables',
						displayOptions: {
							show: {
								enabled: [true],
							},
						},
					},
					{
						displayName: 'Auto-cleanup Temporary Files',
						name: 'autoCleanup',
						type: 'boolean',
						default: true,
						description: 'Automatically delete temporary files after script execution',
						displayOptions: {
							show: {
								enabled: [true],
								accessMethod: ['temp_files', 'both'],
							},
						},
					},
				],
			},
			{
				displayName: 'Output File Processing',
				name: 'outputFileProcessing',
				type: 'collection',
				default: {},
				placeholder: 'Add Output File Options',
				description: 'Configure automatic detection and processing of files generated by Python script',
				options: [
					{
						displayName: 'Enable Output File Processing',
						name: 'enabled',
						type: 'boolean',
						default: false,
						description: 'Automatically detect and process files created by Python script in output directory',
					},
					{
						displayName: 'Max Output File Size (MB)',
						name: 'maxOutputFileSize',
						type: 'number',
						typeOptions: {
							minValue: 1,
							maxValue: 1000,
						},
						default: 100,
						description: 'Maximum output file size to process (1-1000 MB)',
						displayOptions: {
							show: {
								enabled: [true],
							},
						},
					},
					{
						displayName: 'Auto-cleanup Output Directory',
						name: 'autoCleanupOutput',
						type: 'boolean',
						default: true,
						description: 'Automatically delete output directory and files after processing',
						displayOptions: {
							show: {
								enabled: [true],
							},
						},
					},
					{
						displayName: 'Include File Metadata in Output',
						name: 'includeOutputMetadata',
						type: 'boolean',
						default: true,
						description: 'Include file metadata (size, mimetype, etc.) in output JSON',
						displayOptions: {
							show: {
								enabled: [true],
							},
						},
					},
					{
						displayName: 'Auto-Intercept File Operations',
						name: 'autoInterceptFiles',
						type: 'boolean',
						default: true,
						description: 'Automatically redirect all file write operations to output directory (works with any script without modification)',
						displayOptions: {
							show: {
								enabled: [true],
							},
						},
					},
					{
						displayName: 'Expected Output Filename',
						name: 'expectedFileName',
						type: 'string',
						default: 'result.json',
						placeholder: 'report.pdf, data.csv, result.json, etc.',
						description: 'Filename you expect the Python script to create (required for automatic file detection)',
						displayOptions: {
							show: {
								enabled: [true],
							},
						},
					},
					{
						displayName: 'File Detection Mode',
						name: 'fileDetectionMode',
						type: 'options',
						options: [
							{
								name: 'Ready Variable Path',
								value: 'variable_path',
								description: 'Add output_file_path variable with full path to your script (recommended)',
							},
							{
								name: 'Auto Search by Name',
								value: 'auto_search',
								description: 'Automatically find file by name after script execution',
							},
						],
						default: 'variable_path',
						description: 'How to provide the output file path to your Python script',
						displayOptions: {
							show: {
								enabled: [true],
							},
						},
					},
				],
			},
			{
				displayName: 'Parse Output',
				name: 'parseOutput',
				type: 'options',
				options: [
					{
						name: 'None (Raw String)',
						value: 'none',
						description: 'Return stdout as raw string',
					},
					{
						name: 'JSON',
						value: 'json',
						description: 'Parse stdout as JSON object',
					},
					{
						name: 'Lines',
						value: 'lines',
						description: 'Split stdout into array of lines',
					},
					{
						name: 'Smart Auto-detect',
						value: 'smart',
						description: 'Automatically detect and parse JSON, CSV, or return lines',
					},
				],
				default: 'none',
				description: 'How to parse the stdout output for easier data access',
			},
			{
				displayName: 'Parse Options',
				name: 'parseOptions',
				type: 'collection',
				placeholder: 'Add Option',
				default: {},
						displayOptions: {
							show: {
						parseOutput: ['json', 'smart'],
					},
				},
				options: [
					{
						displayName: 'Handle Multiple JSON Objects',
						name: 'multipleJson',
						type: 'boolean',
						default: false,
						description: 'Parse multiple JSON objects separated by newlines',
					},
					{
						displayName: 'Strip Non-JSON Text',
						name: 'stripNonJson',
						type: 'boolean',
						default: true,
						description: 'Remove non-JSON text before and after JSON content',
					},
					{
						displayName: 'Fallback on Parse Error',
						name: 'fallbackOnError',
						type: 'boolean',
						default: true,
						description: 'Keep original stdout if parsing fails',
					},
				],
			},
			{
				displayName: 'Execution Mode',
				name: 'executionMode',
				type: 'options',
				options: [
					{
						name: 'Once for All Items',
						value: 'once',
						description: 'Execute script once with all input items available (faster)',
					},
					{
						name: 'Once per Item',
						value: 'perItem',
						description: 'Execute script separately for each input item (slower but more flexible)',
					},
				],
				default: 'once',
				description: 'Choose how many times to execute the Python script',
			},
			{
				displayName: 'Pass Through Input Data',
				name: 'passThrough',
						type: 'boolean',
				default: false,
				description: 'Include original input data in the output alongside Python script results',
			},
			{
				displayName: 'Pass Through Mode',
				name: 'passThroughMode',
				type: 'options',
						displayOptions: {
							show: {
						passThrough: [true],
					},
				},
				options: [
					{
						name: 'Merge with Result',
						value: 'merge',
						description: 'Add input fields directly to the result object',
					},
					{
						name: 'Separate Field',
						value: 'separate',
						description: 'Add input data as "inputData" field in result',
					},
					{
						name: 'Multiple Outputs',
						value: 'multiple',
						description: 'Return separate items for input data and Python result',
					},
				],
				default: 'separate',
				description: 'How to include input data in the output',
			},
			{
				displayName: 'File Debug Options',
				name: 'fileDebugOptions',
				type: 'collection',
				default: {},
				placeholder: 'Add Debug Options',
				description: 'Advanced debugging options for file processing issues',
				options: [
					{
						displayName: 'Enable File Debugging',
						name: 'enabled',
						type: 'boolean',
						default: false,
						description: 'Include detailed file processing information in output for troubleshooting',
					},
					{
						displayName: 'Debug Input Files',
						name: 'includeInputFileDebug',
						type: 'boolean',
						default: true,
						description: 'Include detailed information about input files processing',
						displayOptions: {
							show: {
								enabled: [true],
							},
						},
					},
					{
						displayName: 'Debug Output Files',
						name: 'includeOutputFileDebug',
						type: 'boolean',
						default: true,
						description: 'Include detailed information about output files and directory scanning',
						displayOptions: {
							show: {
								enabled: [true],
							},
						},
					},
					{
						displayName: 'Include System Information',
						name: 'includeSystemInfo',
						type: 'boolean',
						default: true,
						description: 'Include system information like permissions, disk space, environment variables',
						displayOptions: {
							show: {
								enabled: [true],
							},
						},
					},
					{
						displayName: 'Include Directory Listings',
						name: 'includeDirectoryListing',
						type: 'boolean',
						default: false,
						description: 'Include file listings from working directory, temp directory, and output directory',
						displayOptions: {
							show: {
								enabled: [true],
							},
						},
					},
				],
			},
		],
	};

	methods = {
		loadOptions: {
			async generateCodeTemplate(this: ILoadOptionsFunctions): Promise<INodePropertyOptions[]> {
				try {
					// Get current node parameters
					const currentNodeParameter = this.getCurrentNodeParameter;
					const functionCode = currentNodeParameter('functionCode') as string || '';
					const scriptOptions = (currentNodeParameter('scriptOptions') as IDataObject) || {};
					const fileProcessing = (currentNodeParameter('fileProcessing') as IDataObject) || {};
					const outputFileProcessing = (currentNodeParameter('outputFileProcessing') as IDataObject) || {};
					const hideVariableValues = currentNodeParameter('hideVariableValues') as boolean || false;
					
					// Generate template using the helper function
					const templateCode = generateCodeTemplateStatic(
						functionCode,
						scriptOptions.includeInputItems !== false,
						scriptOptions.includeEnvVarsDict === true,
						hideVariableValues,
						fileProcessing.enabled === true,
						outputFileProcessing.enabled === true,
					);

					// Get statistics about the template
					const lines = templateCode.split('\n');
					const nonEmptyLines = lines.filter(line => line.trim() !== '').length;
					const timestamp = new Date().toLocaleString();
					const hasUserCode = functionCode && functionCode.trim();
					
					// Prepare template preview (first 20 lines)
					const previewLines = lines.slice(0, 20);
					const preview = previewLines.join('\n') + (lines.length > 20 ? '\n\n# ... (truncated)' : '');

					return [
						{
							name: `üîÑ Generated Template (${lines.length} lines, ${nonEmptyLines} non-empty)`,
							value: 'template_generated',
							description: `‚úÖ Template generated at ${timestamp}\n\nüìã Features included:\n‚Ä¢ Input items: ${scriptOptions.includeInputItems !== false ? 'Yes' : 'No'}\n‚Ä¢ Environment variables: ${scriptOptions.includeEnvVarsDict === true ? 'Yes' : 'No'}\n‚Ä¢ File processing: ${fileProcessing.enabled === true ? 'Yes' : 'No'}\n‚Ä¢ Output file processing: ${outputFileProcessing.enabled === true ? 'Yes' : 'No'}\n‚Ä¢ Hidden credentials: ${hideVariableValues ? 'Yes' : 'No'}\n‚Ä¢ User code: ${hasUserCode ? 'Found' : 'None (template only)'}`,
						},
						{
							name: 'üìã Template Preview (first 20 lines)',
							value: 'template_preview',
							description: `\`\`\`python\n${preview}\n\`\`\`\n\nüí° Copy this template to the code field below to see the complete structure that n8n generates around your Python code.`,
						},
						{
							name: 'üìñ Full Template (click to view)',
							value: templateCode,
							description: `Complete auto-generated template with all n8n boilerplate code:\n\n\`\`\`python\n${templateCode}\n\`\`\`\n\nüîß This is the exact code structure that n8n will use when executing your Python function.`,
						},
					];
				} catch (error) {
					return [
						{
							name: '‚ùå Error generating template',
							value: 'error',
							description: `Failed to generate code template: ${error instanceof Error ? error.message : 'Unknown error'}\n\nPlease check your node configuration and try again.`,
						},
					];
				}
			},
			async getSystemEnvVars(this: ILoadOptionsFunctions): Promise<INodePropertyOptions[]> {
				const envVars = Object.keys(process.env).filter(key => {
					// Filter out sensitive or system-specific variables
					const sensitivePatterns = [
						/^HOME$/,
						/^USER$/,
						/^SHELL$/,
						/^PWD$/,
						/^PATH$/,
						/^TEMP$/,
						/^TMP$/,
						/PASS/i,
						/SECRET/i,
						/TOKEN/i,
						/API_KEY/i,
						/PRIVATE/i,
					];
					
					return !sensitivePatterns.some(pattern => pattern.test(key));
				}).sort();
				
				return envVars.map(key => ({
					name: `${key} = ${process.env[key]?.substring(0, 50)}${(process.env[key]?.length || 0) > 50 ? '...' : ''}`,
					value: key,
				}));
			},
			async getPythonEnvVarsCredentials(this: ILoadOptionsFunctions): Promise<INodePropertyOptions[]> {
				try {
					const credentials = await this.getCredentials('pythonEnvVars');
					if (!credentials || !credentials.envFileContent) {
						return [
							{
								name: 'No credentials configured',
								value: '',
								description: 'Please configure Python Environment Variables credentials first',
							},
						];
					}

					const envVars = parseEnvFile(String(credentials.envFileContent));
					const envVarKeys = Object.keys(envVars).sort();

					if (envVarKeys.length === 0) {
						return [
							{
								name: 'No environment variables found',
								value: '',
								description: 'The configured credentials contain no environment variables',
							},
						];
					}

					return envVarKeys.map(key => ({
						name: `${key} = ${envVars[key]?.substring(0, 50)}${(envVars[key]?.length || 0) > 50 ? '...' : ''}`,
						value: key,
					}));
				} catch (error) {
					return [
						{
							name: 'Error loading credentials',
							value: '',
							description: `Failed to load Python Environment Variables credentials: ${error instanceof Error ? error.message : 'Unknown error'}`,
						},
					];
				}
			},
		},
	};

	async execute(this: IExecuteFunctions): Promise<INodeExecutionData[][]> {

		// Initialize Full Debug+ diagnostics
		let fullDebugPlusDiagnostics: FullDebugPlusDiagnostics | null = null;
		const debugMode = this.getNodeParameter('debugMode', 0) as string;
		
		if (debugMode === 'full_plus') {
			fullDebugPlusDiagnostics = createFullDebugPlusDiagnostics();
			console.log('üî¨ ============================================');
			console.log('üî¨ FULL DEBUG+ MODE (Developer Diagnostics)');
			console.log('üî¨ ============================================');
			console.log('üíª System:', fullDebugPlusDiagnostics.system.os.platform, fullDebugPlusDiagnostics.system.os.release);
			console.log('üü¢ Node.js:', fullDebugPlusDiagnostics.system.nodejs.version);
			console.log('üì¶ Package:', fullDebugPlusDiagnostics.node_installation.package.version);
		}

		let items = this.getInputData();
		// Copy the items as they may get changed in the functions
		items = JSON.parse(JSON.stringify(items));

		// Get the python code snippet
		const functionCode = this.getNodeParameter('functionCode', 0) as string;
		const pythonPath = this.getNodeParameter('pythonPath', 0) as string;
		const executionTimeout = this.getNodeParameter('executionTimeout', 0) as number;
		const errorHandling = this.getNodeParameter('errorHandling', 0) as string;
		const parseOutput = this.getNodeParameter('parseOutput', 0) as string;
		const scriptExportFormat = this.getNodeParameter('scriptExportFormat', 0, 'py') as string;
		const parseOptions = (['json', 'smart'].includes(parseOutput)) ? 
			this.getNodeParameter('parseOptions', 0) as ParseOptions : 
			{} as ParseOptions;
		const executionMode = this.getNodeParameter('executionMode', 0) as string;
		const passThrough = this.getNodeParameter('passThrough', 0) as boolean;
		const passThroughMode = passThrough ? this.getNodeParameter('passThroughMode', 0) as string : 'separate';
		
		// Read Data Sources Configuration
		const injectInputVariables = this.getNodeParameter('includeInputVariables', 0, true) as boolean;
		const includeCredentialVars = this.getNodeParameter('includeCredentialVars', 0, false) as boolean;
		const includeSystemEnv = this.getNodeParameter('includeSystemEnv', 0, false) as boolean;
		const systemEnvVarsString = includeSystemEnv ? (this.getNodeParameter('systemEnvVars', 0, '') as string) : '';
		const systemEnvVars = systemEnvVarsString ? systemEnvVarsString.split(',').map(v => v.trim()).filter(v => v) : [];
		
		// For backward compatibility with old script generation options
		const includeInputItems = injectInputVariables; // Use same flag for both individual vars and array
		const includeEnvVarsDict = includeCredentialVars; // Use credential flag for env_vars dict
		
		// Update Full Debug+ diagnostics with real data
		if (fullDebugPlusDiagnostics) {
			// Update package info
			fullDebugPlusDiagnostics.node_installation.package = {
				name: 'n8n-nodes-python-raw',
				version: getPackageVersion(),
				description: 'Python execution for n8n with comprehensive diagnostics',
			};
			// Update node info
			fullDebugPlusDiagnostics.node_installation.node = {
				type: 'n8n-nodes-python-raw.pythonFunctionRaw',
				name: 'Python Raw',
				version: getNodeVersionFromPackage(),
				subtitle: 'Run custom Python script once and return raw output',
				credentials_available: ['pythonEnvVars'],
				parameters_count: 15, // Approximate count
				outputs_count: 2,
			};
			// Update Python info
			if (fullDebugPlusDiagnostics) {
				const pythonDiag = await getPythonDiagnostics(pythonPath);
				fullDebugPlusDiagnostics.system.python = {
					executable: pythonPath,
					version_command: `${pythonPath} --version`,
					version_output: pythonDiag.version_output,
					path_resolved: pythonPath,
					is_found: !!pythonDiag.version_output && !pythonDiag.version_output.startsWith('Error'),
					version_details: pythonDiag.version_details,
					installed_packages: pythonDiag.installed_packages,
				};
				
				console.log('üêç Python:', pythonDiag.version_output);
				if (pythonDiag.installed_packages) {
					console.log(`üì¶ Python packages: ${pythonDiag.installed_packages.package_count} installed`);
				}
			}
			// Update n8n info
			fullDebugPlusDiagnostics.system.n8n.workflow_id = String(this.getWorkflow().id || 'unknown');
			fullDebugPlusDiagnostics.system.n8n.execution_id = 'unknown'; // getExecutionId() not available in IExecuteFunctions
			
			console.log('üìã Node Configuration:', {
				injectInputVariables,
				includeCredentialVars,
				includeSystemEnv,
				executionMode,
				parseOutput,
				debugMode,
			});
		}
		
		// Get file processing options
		const fileProcessingConfig = this.getNodeParameter('fileProcessing', 0, {}) as {
			enabled?: boolean;
			accessMethod?: string;
			maxFileSize?: number;
			includeMetadata?: boolean;
			autoCleanup?: boolean;
		};
		
		const fileProcessingOptions: FileProcessingOptions = {
			enabled: fileProcessingConfig.enabled === true, // default false
			accessMethod: (fileProcessingConfig.accessMethod as 'temp_files' | 'base64' | 'both') || 'temp_files',
			maxFileSize: fileProcessingConfig.maxFileSize || 100,
			includeMetadata: fileProcessingConfig.includeMetadata !== false, // default true
			autoCleanup: fileProcessingConfig.autoCleanup !== false, // default true
		};
		
		// Get output file processing options
		const outputFileProcessingConfig = this.getNodeParameter('outputFileProcessing', 0, {}) as {
			enabled?: boolean;
			maxOutputFileSize?: number;
			autoCleanupOutput?: boolean;
			includeOutputMetadata?: boolean;
			autoInterceptFiles?: boolean;
			expectedFileName?: string;
			fileDetectionMode?: 'variable_path' | 'auto_search';
		};
		
		const outputFileProcessingOptions: OutputFileProcessingOptions = {
			enabled: outputFileProcessingConfig.enabled === true, // default false
			maxOutputFileSize: outputFileProcessingConfig.maxOutputFileSize || 100,
			autoCleanupOutput: outputFileProcessingConfig.autoCleanupOutput !== false, // default true
			includeOutputMetadata: outputFileProcessingConfig.includeOutputMetadata !== false, // default true
			autoInterceptFiles: outputFileProcessingConfig.autoInterceptFiles !== false, // default false
			expectedFileName: outputFileProcessingConfig.expectedFileName,
			fileDetectionMode: outputFileProcessingConfig.fileDetectionMode || 'variable_path',
		};
		
		// Get file debug options
		const fileDebugConfig = this.getNodeParameter('fileDebugOptions', 0, {}) as {
			enabled?: boolean;
			includeInputFileDebug?: boolean;
			includeOutputFileDebug?: boolean;
			includeSystemInfo?: boolean;
			includeDirectoryListing?: boolean;
		};
		
		const fileDebugOptions: FileDebugOptions = {
			enabled: fileDebugConfig.enabled === true, // default false
			includeInputFileDebug: fileDebugConfig.includeInputFileDebug !== false, // default true when debugging enabled
			includeOutputFileDebug: fileDebugConfig.includeOutputFileDebug !== false, // default true when debugging enabled
			includeSystemInfo: fileDebugConfig.includeSystemInfo !== false, // default true when debugging enabled
			includeDirectoryListing: fileDebugConfig.includeDirectoryListing === true, // default false
		};
		
		// Create output directory if output file processing is enabled
		let outputDir: string | undefined;
		let outputDirToCleanup: string | undefined;
		
		if (outputFileProcessingOptions.enabled) {
			try {
				outputDir = createUniqueOutputDirectory();
				if (outputFileProcessingOptions.autoCleanupOutput) {
					outputDirToCleanup = outputDir;
				}
				console.log(`Output file processing enabled, created directory: ${outputDir}`);
			} catch (error) {
				console.error('Failed to create output directory:', error);
				throw new NodeOperationError(this.getNode(), `Failed to create output directory: ${(error as Error).message}`);
			}
		}
		
		// Log configuration
		console.log('Python Function Raw node configuration:', {
			pythonPath,
			injectInputVariables,
			includeCredentialVars,
			includeSystemEnv,
			errorHandling,
			 debugMode,
			parseOutput,
			parseOptions,
			executionMode,
			passThrough,
			passThroughMode,
			inputItemsCount: items.length,
		});
		
		// Get hide variable values configuration
		const hideCredentialValues = this.getNodeParameter('hideVariableValues', 0, false) as boolean;
		
		// Get the environment variables from credentials
		let pythonEnvVars: Record<string, string> = {};
		let credentialSources: Record<string, string> = {};
		
		// Full Debug+: Diagnose input data
		if (fullDebugPlusDiagnostics) {
			const firstItem = items.length > 0 ? items[0].json : {};
			const allItemsSizes = items.map(item => JSON.stringify(item).length);
			const totalDataSize = allItemsSizes.reduce((sum, size) => sum + size, 0);
			
			fullDebugPlusDiagnostics.data_sources.input_variables = {
				enabled: injectInputVariables,
				items_received: items.length,
				items_have_data: Object.keys(firstItem).length > 0,
				first_item_keys: Object.keys(firstItem),
				first_item_structure: Object.keys(firstItem).reduce((acc, key) => {
					acc[key] = typeof firstItem[key];
					return acc;
				}, {} as Record<string, string>),
				all_items_sizes: allItemsSizes,
				total_data_kb: Math.round(totalDataSize / 1024),
			};
			
			console.log('üì• Input Data Diagnostics:', {
				enabled: injectInputVariables,
				items_count: items.length,
				has_data: Object.keys(firstItem).length > 0,
				first_item_keys: Object.keys(firstItem),
				total_size_kb: Math.round(totalDataSize / 1024),
			});
		}
		
		try {
			// Load credentials only if enabled in Data Sources Configuration
			if (includeCredentialVars) {
				// Load default credential
					const credentialData = await this.getCredentials('pythonEnvVars');
				
				// Full Debug+: Update credential diagnostics
				if (fullDebugPlusDiagnostics) {
					fullDebugPlusDiagnostics.data_sources.credentials.enabled = true;
					fullDebugPlusDiagnostics.data_sources.credentials.credential_connected = !!credentialData;
					fullDebugPlusDiagnostics.data_sources.credentials.credential_name = String(credentialData?.name || '');
					fullDebugPlusDiagnostics.data_sources.credentials.raw_credential_data_keys = credentialData ? Object.keys(credentialData) : [];
					fullDebugPlusDiagnostics.data_sources.credentials.envFileContent_exists = !!(credentialData?.envFileContent);
					fullDebugPlusDiagnostics.data_sources.credentials.envFileContent_length = String(credentialData?.envFileContent || '').length;
					
					// Handle credential preview with hide values option
					let previewLines = String(credentialData?.envFileContent || '').split('\n').slice(0, 3);
					if (hideCredentialValues) {
						// Hide values but keep variable names
						previewLines = previewLines.map(line => {
							const eqIndex = line.indexOf('=');
							if (eqIndex > 0) {
								const varName = line.substring(0, eqIndex);
								return `${varName}=***hidden***`;
							}
							return line;
						});
					}
					fullDebugPlusDiagnostics.data_sources.credentials.envFileContent_preview_first_3_lines = previewLines;
				}
				
					if (credentialData && credentialData.envFileContent) {
						pythonEnvVars = parseEnvFile(String(credentialData.envFileContent));
						const credentialName = String(credentialData.name || 'default_credential');
						credentialSources = Object.keys(pythonEnvVars).reduce((acc, key) => {
							acc[key] = credentialName;
							return acc;
						}, {} as Record<string, string>);
					console.log(`Loaded ${Object.keys(pythonEnvVars).length} variables from credential (${credentialName})`);
					
					// Full Debug+: Update parsing success
					if (fullDebugPlusDiagnostics) {
						fullDebugPlusDiagnostics.data_sources.credentials.parsing_attempted = true;
						fullDebugPlusDiagnostics.data_sources.credentials.parsing_successful = true;
						fullDebugPlusDiagnostics.data_sources.credentials.variables_parsed = Object.keys(pythonEnvVars).length;
						fullDebugPlusDiagnostics.data_sources.credentials.variable_names = Object.keys(pythonEnvVars);
						fullDebugPlusDiagnostics.data_sources.credentials.variable_types = Object.keys(pythonEnvVars).reduce((acc, key) => {
							acc[key] = typeof pythonEnvVars[key];
							return acc;
						}, {} as Record<string, string>);
					}
				}
			} else {
				console.log('Credential variables disabled in Data Sources Configuration');
			}
		} catch (error) {
			console.warn('Error loading credentials:', error);
			
			// Full Debug+: Update parsing error
			if (fullDebugPlusDiagnostics) {
				fullDebugPlusDiagnostics.data_sources.credentials.parse_error = (error as Error).message;
				fullDebugPlusDiagnostics.errors_and_warnings.errors.push(`Credential loading error: ${(error as Error).message}`);
			}
			
			if (Object.keys(pythonEnvVars).length === 0) {
				pythonEnvVars = {};
				credentialSources = {};
			}
		}
		
		// Add selected system environment variables (only if enabled)
		const systemEnvVarsToAdd: Record<string, string> = {};
		if (includeSystemEnv) {
			for (const envVarName of systemEnvVars) {
				if (process.env[envVarName] !== undefined) {
					systemEnvVarsToAdd[envVarName] = process.env[envVarName]!;
				}
			}
			console.log(`Loaded ${Object.keys(systemEnvVarsToAdd).length} system environment variables`);
			
			// Full Debug+: Update system environment diagnostics
			if (fullDebugPlusDiagnostics) {
				const foundVars = Object.keys(systemEnvVarsToAdd);
				const missingVars = systemEnvVars.filter(name => !foundVars.includes(name));
				
				// Handle system environment values preview with hide values option
				let foundValuesPreview: Record<string, string> = {};
				if (hideCredentialValues) {
					// Hide values, keep only indication that they exist
					foundValuesPreview = Object.keys(systemEnvVarsToAdd).reduce((acc, key) => {
						acc[key] = '***hidden***';
						return acc;
					}, {} as Record<string, string>);
				} else {
					foundValuesPreview = Object.keys(systemEnvVarsToAdd).reduce((acc, key) => {
						acc[key] = systemEnvVarsToAdd[key].substring(0, 20) + (systemEnvVarsToAdd[key].length > 20 ? '...' : '');
						return acc;
					}, {} as Record<string, string>);
				}
				
				fullDebugPlusDiagnostics.data_sources.system_environment = {
					enabled: true,
					total_env_vars_available: Object.keys(process.env).length,
					requested_vars: systemEnvVars,
					found_vars: foundVars,
					missing_vars: missingVars,
					found_values_preview: foundValuesPreview,
					all_process_env_keys: Object.keys(process.env).slice(0, 50),
				};
			}
		} else {
			console.log('System environment variables disabled in Data Sources Configuration');
		}
		
		// Merge system env vars with credential env vars (credentials take precedence)
		const mergedEnvVars = { ...systemEnvVarsToAdd, ...pythonEnvVars };
		
		// Add credential source tracking to merged env vars
		const mergedCredentialSources = { 
			...Object.keys(systemEnvVarsToAdd).reduce((acc, key) => {
				acc[key] = 'system_environment';
				return acc;
			}, {} as Record<string, string>),
			...credentialSources,
		};
		
		// Process binary files if enabled
		let inputFiles: FileMapping[] = [];
		let tempFilesToCleanup: FileMapping[] = [];
		
		if (fileProcessingOptions.enabled) {
			try {
				console.log('File processing enabled, detecting binary files...');
				const binaryFiles = detectBinaryFiles(items);
				
				if (binaryFiles.length > 0) {
					console.log(`Found ${binaryFiles.length} binary files in input`);
					inputFiles = await createTemporaryFiles(binaryFiles, fileProcessingOptions);
					
					// Keep track of temp files for cleanup
					if (fileProcessingOptions.autoCleanup) {
						tempFilesToCleanup = inputFiles.filter(f => f.tempPath);
					}
					
					console.log(`Processed ${inputFiles.length} files for Python script access`);
				} else {
					console.log('No binary files found in input data');
				}
		} catch (error) {
				console.error('File processing failed:', error);
				// Cleanup any partial temp files
				if (tempFilesToCleanup.length > 0) {
					await cleanupTemporaryFiles(tempFilesToCleanup);
				}
				throw new NodeOperationError(this.getNode(), `File processing failed: ${(error as Error).message}`);
			}
		}
		
		// Prepare to pass inputFiles to execution functions  
		try {
			// Execute based on mode
			if (executionMode === 'perItem') {
				return await executePerItem(
					this,
					functionCode, 
					pythonPath, 
					executionTimeout,
					injectInputVariables, // Use new parameter instead of old injectVariables
					errorHandling, 
					debugMode, 
					parseOutput, 
					parseOptions, 
					passThrough, 
					passThroughMode, 
					items, 
					mergedEnvVars,
					includeInputItems, // Use new parameter
					Object.keys(mergedEnvVars).length > 0, // Always include env_vars dict if has variables
					hideCredentialValues,
					systemEnvVars,
					mergedCredentialSources,
					inputFiles,
					outputDir,
					outputFileProcessingOptions,
					fileDebugOptions,
					scriptExportFormat,
				);
			} else {
				return await executeOnce(
					this,
					functionCode, 
					pythonPath, 
					executionTimeout,
					injectInputVariables, // Use new parameter instead of old injectVariables
					errorHandling, 
					debugMode, 
					parseOutput, 
					parseOptions, 
					passThrough, 
					passThroughMode, 
					items, 
					mergedEnvVars,
					includeInputItems, // Use new parameter
					Object.keys(mergedEnvVars).length > 0, // Always include env_vars dict if has variables
					hideCredentialValues,
					systemEnvVars,
					mergedCredentialSources,
					inputFiles,
					outputDir,
					outputFileProcessingOptions,
					fileDebugOptions,
					scriptExportFormat,
					fullDebugPlusDiagnostics,
				);
			}
		} catch (error) {
			throw new NodeOperationError(this.getNode(), `Error executing Python script: ${(error as Error).message}`);
		} finally {
			// Cleanup temporary files if enabled
			if (tempFilesToCleanup.length > 0) {
				await cleanupTemporaryFiles(tempFilesToCleanup);
			}
			
			// Cleanup output directory if needed
			if (outputDirToCleanup) {
				try {
					await cleanupOutputDirectory(outputDirToCleanup);
				} catch (error) {
					console.warn('Failed to cleanup output directory:', error);
					// Don't throw error - cleanup should not break main process
				}
			}
		}
	}
}
async function loadMultipleCredentials(
	executeFunctions: IExecuteFunctions,
	config: {
		credentialNamesList?: string;
		additionalCredential1?: string;
		additionalCredential2?: string;
		additionalCredential3?: string;
		credentialCollection?: { credentials: Array<{ credentialName: string; variablePrefix?: string }> };
		jsonConfiguration?: string;
	},
	method: string,
	mergeStrategy: string,
): Promise<{envVars: Record<string, string>, credentialSources: Record<string, string>}> {
	const envVars: Record<string, string> = {};
	const credentialSources: Record<string, string> = {};
	
	try {
		switch (method) {
			case 'names_list':
				return await loadCredentialsFromNamesList(executeFunctions, config.credentialNamesList || '');
			
			case 'selectors':
				return await loadCredentialsFromSelectors(executeFunctions, config);
			
			case 'collection':
				return await loadCredentialsFromCollection(executeFunctions, config.credentialCollection);
			
			case 'json_config':
				return await loadCredentialsFromJsonConfig(executeFunctions, config.jsonConfiguration || '{}');
			
			default:
				return { envVars, credentialSources };
		}
	} catch (error) {
		console.warn(`Error loading multiple credentials (${method}):`, error);
		return { envVars, credentialSources };
	}
}

// Load credentials from comma-separated names list
async function loadCredentialsFromNamesList(
	executeFunctions: IExecuteFunctions,
	namesList: string,
): Promise<{envVars: Record<string, string>, credentialSources: Record<string, string>}> {
	const envVars: Record<string, string> = {};
	const credentialSources: Record<string, string> = {};
	
	if (!namesList || namesList.trim() === '') {
		return { envVars, credentialSources };
	}
	
	const credentialNames = namesList.split(',').map(name => name.trim()).filter(name => name);
	console.log(`Loading credentials from names list: ${credentialNames.join(', ')}`);
	
	// For each name, try to load a credential (simulated since n8n API limitations)
	for (const credentialName of credentialNames) {
		try {
			// In real implementation, this would load specific credentials by name
			// For now, we simulate by using the default credential
			const credentialData = await executeFunctions.getCredentials('pythonEnvVars');
			if (credentialData && credentialData.envFileContent) {
				const vars = parseEnvFile(String(credentialData.envFileContent));
				for (const [key, value] of Object.entries(vars)) {
					envVars[key] = String(value);
					credentialSources[key] = credentialName;
				}
			}
		} catch (error) {
			console.warn(`Failed to load credential: ${credentialName}`, error);
		}
	}
	
	return { envVars, credentialSources };
}

// Load credentials from selector fields
async function loadCredentialsFromSelectors(
	executeFunctions: IExecuteFunctions,
	config: {
		additionalCredential1?: string;
		additionalCredential2?: string;
		additionalCredential3?: string;
	},
): Promise<{envVars: Record<string, string>, credentialSources: Record<string, string>}> {
	const envVars: Record<string, string> = {};
	const credentialSources: Record<string, string> = {};
	
	const credentialNames = [
		config.additionalCredential1,
		config.additionalCredential2,
		config.additionalCredential3,
	].filter(name => name && name.trim() !== '');
	
	console.log(`Loading credentials from selectors: ${credentialNames.join(', ')}`);
	
	return await loadCredentialsFromNamesList(executeFunctions, credentialNames.join(', '));
}

// Load credentials from dynamic collection
async function loadCredentialsFromCollection(
	executeFunctions: IExecuteFunctions,
	collection: { credentials?: Array<{ credentialName: string; variablePrefix?: string }> } | undefined,
): Promise<{envVars: Record<string, string>, credentialSources: Record<string, string>}> {
	const envVars: Record<string, string> = {};
	const credentialSources: Record<string, string> = {};
	
	if (!collection || !collection.credentials || !Array.isArray(collection.credentials)) {
		return { envVars, credentialSources };
	}
	
	console.log(`Loading credentials from collection: ${collection.credentials.length} items`);
	
	for (const item of collection.credentials) {
		if (!item.credentialName || item.credentialName.trim() === '') continue;
		
		try {
			// Simulate loading credential by name
			const credentialData = await executeFunctions.getCredentials('pythonEnvVars');
			if (credentialData && credentialData.envFileContent) {
				const vars = parseEnvFile(String(credentialData.envFileContent));
				const prefix = item.variablePrefix || '';
				
				for (const [key, value] of Object.entries(vars)) {
					const finalKey = prefix ? `${prefix}${key}` : key;
					envVars[finalKey] = String(value);
					credentialSources[finalKey] = item.credentialName;
				}
			}
		} catch (error) {
			console.warn(`Failed to load credential from collection: ${item.credentialName}`, error);
		}
	}
	
	return { envVars, credentialSources };
}

// Load credentials from JSON configuration
async function loadCredentialsFromJsonConfig(
	executeFunctions: IExecuteFunctions,
	jsonConfig: string,
): Promise<{envVars: Record<string, string>, credentialSources: Record<string, string>}> {
	const envVars: Record<string, string> = {};
	const credentialSources: Record<string, string> = {};
	
	try {
		const config = JSON.parse(jsonConfig);
		if (!config.credentials || !Array.isArray(config.credentials)) {
			throw new Error('JSON configuration must have a "credentials" array');
		}
		
		console.log(`Loading credentials from JSON config: ${config.credentials.length} items`);
		
		for (const item of config.credentials) {
			if (!item.name || item.name.trim() === '') continue;
			
			try {
				// Simulate loading credential by name
				const credentialData = await executeFunctions.getCredentials('pythonEnvVars');
				if (credentialData && credentialData.envFileContent) {
					const vars = parseEnvFile(String(credentialData.envFileContent));
					const prefix = item.prefix || '';
					
					for (const [key, value] of Object.entries(vars)) {
						const finalKey = prefix ? `${prefix}${key}` : key;
						envVars[finalKey] = String(value);
						credentialSources[finalKey] = item.name;
					}
				}
			} catch (error) {
				console.warn(`Failed to load credential from JSON config: ${item.name}`, error);
			}
		}
	} catch (error) {
		console.warn('Failed to parse JSON configuration:', error);
	}
	
	return { envVars, credentialSources };
}

async function getPythonDiagnostics(pythonPath: string): Promise<{
	version_output: string;
	version_details: { full_version: string; major: number; minor: number; micro: number } | null;
	installed_packages: {
		package_count: number;
		packages_list: string[];
		pip_freeze_command: string;
		pip_freeze_successful: boolean;
		pip_freeze_error: string | null;
	} | null;
}> {
	const result = {
		version_output: '',
		version_details: null as { full_version: string; major: number; minor: number; micro: number } | null,
		installed_packages: null as {
			package_count: number;
			packages_list: string[];
			pip_freeze_command: string;
			pip_freeze_successful: boolean;
			pip_freeze_error: string | null;
		} | null,
	};
	
	// Get Python version
	try {
		const { spawn } = require('child_process');
		const versionProcess = spawn(pythonPath, ['--version']);
		
		let stdout = '';
		let stderr = '';
		
		versionProcess.stdout?.on('data', (data: Buffer) => {
			stdout += data.toString();
		});
		
		versionProcess.stderr?.on('data', (data: Buffer) => {
			stderr += data.toString();
		});
		
		await new Promise((resolve) => {
			versionProcess.on('close', resolve);
		});
		
		result.version_output = (stdout + stderr).trim();
		
		// Parse version (e.g., "Python 3.12.11")
		const versionMatch = result.version_output.match(/Python (\d+)\.(\d+)\.(\d+)/);
		if (versionMatch) {
			result.version_details = {
				full_version: versionMatch[0],
				major: parseInt(versionMatch[1]),
				minor: parseInt(versionMatch[2]),
				micro: parseInt(versionMatch[3]),
			};
		}
	} catch (error) {
		result.version_output = `Error: ${(error as Error).message}`;
	}
	
	// Get installed packages
	try {
		const { spawn } = require('child_process');
		const pipProcess = spawn(pythonPath, ['-m', 'pip', 'freeze']);
		
		let stdout = '';
		let stderr = '';
		
		pipProcess.stdout?.on('data', (data: Buffer) => {
			stdout += data.toString();
		});
		
		pipProcess.stderr?.on('data', (data: Buffer) => {
			stderr += data.toString();
		});
		
		await new Promise((resolve) => {
			pipProcess.on('close', resolve);
		});
		
		if (stdout) {
			const packages = stdout.trim().split('\n').filter(line => line.trim());
			result.installed_packages = {
				package_count: packages.length,
				packages_list: packages.slice(0, 50),  // First 50 for preview
				pip_freeze_command: `${pythonPath} -m pip freeze`,
				pip_freeze_successful: true,
				pip_freeze_error: null,
			};
		} else {
			result.installed_packages = {
				package_count: 0,
				packages_list: [],
				pip_freeze_command: `${pythonPath} -m pip freeze`,
				pip_freeze_successful: false,
				pip_freeze_error: stderr || 'No output from pip freeze',
			};
		}
	} catch (error) {
		result.installed_packages = {
			package_count: 0,
			packages_list: [],
			pip_freeze_command: `${pythonPath} -m pip freeze`,
			pip_freeze_successful: false,
			pip_freeze_error: (error as Error).message,
		};
	}
	
	return result;
}


async function executeOnce(
	executeFunctions: IExecuteFunctions,
	functionCode: string,
	pythonPath: string,
	executionTimeout: number,
	injectInputVariables: boolean,
	errorHandling: string,
	debugMode: string,
	parseOutput: string,
	parseOptions: ParseOptions,
	passThrough: boolean,
	passThroughMode: string,
	items: INodeExecutionData[],
	pythonEnvVars: Record<string, string>,
	includeInputItems: boolean,
	includeEnvVarsDict: boolean,
	hideVariableValues: boolean,
	systemEnvVars: string[],
	credentialSources: Record<string, string>,
	inputFiles: FileMapping[],
	outputDir?: string,
	outputFileProcessingOptions?: OutputFileProcessingOptions,
	fileDebugOptions?: FileDebugOptions,
	scriptExportFormat?: string,
	fullDebugPlusDiagnostics?: FullDebugPlusDiagnostics | null,
): Promise<INodeExecutionData[][]> {

	// Create debug timing and info variables in function scope
	const debugTiming: DebugTiming = {
			script_created_at: new Date().toISOString(),
	};
	let debugInfo: DebugInfo | null = null;
		
	let scriptPath = '';
	let executionDir = '';
	try {
		// Create execution directory first
		executionDir = createExecutionDirectory();
		
		// Always call getTemporaryScriptPath to ensure reserved variables are defined
		// Pass empty arrays/objects when injectInputVariables is false
		scriptPath = await getTemporaryScriptPath(
			functionCode, 
			injectInputVariables ? unwrapJsonField(items) : [], 
			pythonEnvVars, 
			includeInputItems, 
			includeEnvVarsDict, 
			hideVariableValues, 
			credentialSources, 
			inputFiles, 
			outputDir, 
			outputFileProcessingOptions
		);
		
		// Full Debug+: Diagnose script generation
		if (fullDebugPlusDiagnostics) {
			const scriptContent = getScriptCode(
				functionCode, 
				injectInputVariables ? unwrapJsonField(items) : [], 
				pythonEnvVars, 
				includeInputItems, 
				includeEnvVarsDict, 
				hideVariableValues, 
				credentialSources, 
				inputFiles, 
				outputDir, 
				outputFileProcessingOptions
			);
			
			fullDebugPlusDiagnostics.script_generation.user_code = {
				provided: !!functionCode && functionCode.trim().length > 0,
				length_chars: functionCode.length,
				lines_count: functionCode.split('\n').length,
				has_imports: functionCode.includes('import ') || functionCode.includes('from '),
				has_future_imports: functionCode.includes('from __future__'),
			};
			
			fullDebugPlusDiagnostics.script_generation.template = {
				sections_generated: [
					'header',
					'individual_variables',
					'env_variables',
					'reserved_variables',
					'user_code'
				],
				individual_vars_count: injectInputVariables ? unwrapJsonField(items).length : 0,
				env_vars_count: Object.keys(pythonEnvVars).length,
				reserved_vars_defined: ['input_items', 'env_vars', 'input_files', 'output_dir'],
				input_files_count: inputFiles ? inputFiles.length : 0,
				output_dir_provided: !!outputDir,
			};
			
			fullDebugPlusDiagnostics.script_generation.final_script = {
				total_length_chars: scriptContent.length,
				total_lines_count: scriptContent.split('\n').length,
				header_length: scriptContent.indexOf('# User code starts here') > 0 ? scriptContent.indexOf('# User code starts here') : 0,
				user_code_length: functionCode.length,
				estimated_size_kb: Math.round(scriptContent.length / 1024),
			};
			
			// Store the complete assembled script for Full Debug+ display
			fullDebugPlusDiagnostics.script_generation.full_assembled_script = scriptContent;
			
			console.log('üìù Script Generation Diagnostics:', {
				user_code_provided: fullDebugPlusDiagnostics.script_generation.user_code.provided,
				user_code_length: fullDebugPlusDiagnostics.script_generation.user_code.length_chars,
				total_script_length: fullDebugPlusDiagnostics.script_generation.final_script.total_length_chars,
				individual_vars: fullDebugPlusDiagnostics.script_generation.template.individual_vars_count,
				env_vars: fullDebugPlusDiagnostics.script_generation.template.env_vars_count,
				estimated_size_kb: fullDebugPlusDiagnostics.script_generation.final_script.estimated_size_kb,
			});
			}
			
			// Add output_dir to environment variables if Output File Processing is enabled
			if (outputDir) {
				pythonEnvVars.output_dir = outputDir;
				if (outputFileProcessingOptions?.expectedFileName) {
					pythonEnvVars.expected_filename = outputFileProcessingOptions.expectedFileName;
				}
				pythonEnvVars.output_file_path = outputDir + (outputFileProcessingOptions?.expectedFileName ? `/${outputFileProcessingOptions.expectedFileName}` : '');
			}
		
		// Move script to execution directory
		const scriptFileName = path.basename(scriptPath);
		const newScriptPath = path.join(executionDir, scriptFileName);
		fs.copyFileSync(scriptPath, newScriptPath);
		fs.unlinkSync(scriptPath); // Remove original script
		scriptPath = newScriptPath;
		
		console.log(`Moved script to execution directory: ${scriptPath}`);
	} catch (error) {
		// Cleanup execution directory if script creation failed
		if (executionDir) {
			await cleanupExecutionDirectory(executionDir);
		}
		throw new NodeOperationError(executeFunctions.getNode(), `Could not generate temporary script file: ${(error as Error).message}`);
	}

	try {
		// Initialize debug information
		if (debugMode !== 'off') {
			let scriptContent: string;
			
			if (debugMode === 'export') {
				// For export mode, use special function without env_vars
				scriptContent = getScriptCodeForExport(
					functionCode, 
					injectInputVariables ? unwrapJsonField(items) : [], 
					inputFiles, 
					outputDir, 
					outputFileProcessingOptions
				);
			} else {
				// For other debug modes, use full function with env_vars
				scriptContent = getScriptCode(
					functionCode, 
					injectInputVariables ? unwrapJsonField(items) : [], 
					pythonEnvVars, 
					includeInputItems, 
					includeEnvVarsDict, 
					hideVariableValues, 
					credentialSources, 
					inputFiles || [], 
					outputDir || '', 
					outputFileProcessingOptions
				);
			}
			
			debugInfo = await createDebugInfo(
				scriptPath,
				scriptContent,
				 pythonPath,
				injectInputVariables ? unwrapJsonField(items) : undefined,
				(injectInputVariables && debugMode !== 'export') ? pythonEnvVars : undefined,
				 debugTiming,
				 credentialSources,
			);
		}

		// For Test Only mode, return validation results without execution
		if (debugMode === 'test') {
			const testResult: IDataObject = {
				exitCode: null,
				stdout: '',
				stderr: '',
				success: null,
				error: null,
				inputItemsCount: items.length,
				executedAt: new Date().toISOString(),
				includeInputVariables: injectInputVariables,
				parseOutput,
				executionMode: 'once',
				test_mode: true,
				execution_skipped: true,
			};

			if (debugInfo) {
				addDebugInfoToResult(testResult, debugInfo, debugMode);
			}

			const testResultWithPassThrough = handlePassThroughData(testResult, items, passThrough, passThroughMode);
			return [testResultWithPassThrough, []];
		}

		// Execute the Python script
		debugTiming.execution_started_at = new Date().toISOString();
		
		// Full Debug+: Update execution diagnostics
		if (fullDebugPlusDiagnostics) {
			fullDebugPlusDiagnostics.execution.preparation.temp_dir_created = executionDir;
			fullDebugPlusDiagnostics.execution.preparation.script_file_path = scriptPath;
			fullDebugPlusDiagnostics.execution.preparation.script_file_size_bytes = fs.statSync(scriptPath).size;
			fullDebugPlusDiagnostics.execution.preparation.script_written_successfully = true;
			
			fullDebugPlusDiagnostics.execution.command = {
				executable: pythonPath,
				full_command: `${pythonPath} ${scriptPath}`,
				arguments: [scriptPath],
				working_directory: executionDir,
				timeout_minutes: executionTimeout,
			};
			
			fullDebugPlusDiagnostics.execution.timing.preparation_started = debugTiming.script_created_at;
			fullDebugPlusDiagnostics.execution.timing.script_created = debugTiming.script_created_at;
			fullDebugPlusDiagnostics.execution.timing.execution_started = debugTiming.execution_started_at;
			
			console.log('üöÄ Execution Diagnostics:', {
				script_path: scriptPath,
				execution_dir: executionDir,
				script_size_bytes: fullDebugPlusDiagnostics.execution.preparation.script_file_size_bytes,
				python_executable: pythonPath,
				timeout_minutes: executionTimeout,
			});
		}
		
		const execResults = await execPythonSpawn(scriptPath, pythonPath, executionDir, executionTimeout, executeFunctions.sendMessageToUI);
		debugTiming.execution_finished_at = new Date().toISOString();
		debugTiming.total_duration_ms = new Date(debugTiming.execution_finished_at).getTime() - 
			new Date(debugTiming.execution_started_at).getTime();

		// Full Debug+: Update execution result diagnostics
		if (fullDebugPlusDiagnostics) {
			fullDebugPlusDiagnostics.execution.timing.execution_finished = debugTiming.execution_finished_at;
			fullDebugPlusDiagnostics.execution.timing.execution_duration_ms = debugTiming.total_duration_ms;
			fullDebugPlusDiagnostics.execution.timing.total_duration_ms = debugTiming.total_duration_ms;
			
			fullDebugPlusDiagnostics.execution.result = {
				exit_code: execResults.exitCode,
				stdout_length: execResults.stdout.length,
				stderr_length: execResults.stderr.length,
				timed_out: false, // Will be updated if timeout occurred
				killed: false, // Will be updated if process was killed
				signal: null, // Will be updated if signal was used
			};
			
			console.log('üìä Execution Results:', {
				exit_code: execResults.exitCode,
				stdout_length: execResults.stdout.length,
				stderr_length: execResults.stderr.length,
				execution_duration_ms: debugTiming.total_duration_ms,
				success: execResults.exitCode === 0,
			});
		}

			const {
				error: returnedError,
				exitCode,
			stdout,
			stderr,
			} = execResults;

		// Parse stdout based on configuration
		let parseResult: ParseResult | null = null;
		if (parseOutput !== 'none') {
			parseResult = parseStdout(stdout, parseOutput, parseOptions);
			console.log('Parse result:', parseResult);
		}

		// Base result object
		const baseResult: IDataObject = {
			exitCode,
			stdout,
			stderr,
			success: exitCode === 0,
			error: exitCode === 0 ? null : 'Script execution failed',
			inputItemsCount: items.length,
			executedAt: new Date().toISOString(),
			includeInputVariables: injectInputVariables,
			parseOutput,
			executionMode: 'once',
		};

		// Add parsing results if enabled
		if (parseResult) {
			Object.assign(baseResult, {
				parsed_stdout: parseResult.parsed_stdout,
				parsing_success: parseResult.parsing_success,
				parsing_error: parseResult.parsing_error,
				output_format: parseResult.output_format,
				parsing_method: parseResult.parsing_method,
			});
		}

		// Process output files if enabled
		if (outputFileProcessingOptions?.enabled && outputDir) {
			try {
				const outputFiles = await scanOutputDirectory(outputDir, outputFileProcessingOptions);
				
				// Add output file information to result
				baseResult.outputFiles = outputFiles;
				baseResult.outputFilesCount = outputFiles.length;
				
				console.log(`Found ${outputFiles.length} output files for processing`);
			} catch (error) {
				console.error('Error processing output files:', error);
				baseResult.outputFileError = `Failed to process output files: ${(error as Error).message}`;
			}
		}

		// Add file debug information if enabled
		if (fileDebugOptions?.enabled) {
			try {
				const fileDebugInfo = await createFileDebugInfo(
					inputFiles,
					outputDir,
					outputFileProcessingOptions,
					fileDebugOptions,
				);
				baseResult.fileDebugInfo = fileDebugInfo;
				console.log('File debug information added to result');
			} catch (error) {
				console.error('Error creating file debug info:', error);
				baseResult.fileDebugError = `Failed to create file debug info: ${(error as Error).message}`;
			}
		}

		// Add debug information if enabled
		if (debugInfo && debugMode !== 'off') {
				debugInfo.timing = debugTiming;
				addDebugInfoToResult(baseResult, debugInfo, debugMode);
		}

		// Handle pass through data
		const resultWithPassThrough = handlePassThroughData(baseResult, items, passThrough, passThroughMode);

		// Add output files as binary data if enabled
		if (outputFileProcessingOptions?.enabled && baseResult.outputFiles && Array.isArray(baseResult.outputFiles)) {
			for (const resultItem of resultWithPassThrough) {
				for (const outputFile of baseResult.outputFiles as OutputFileInfo[]) {
					if (!resultItem.binary) {
						resultItem.binary = {};
					}
					resultItem.binary[outputFile.binaryKey] = {
						data: outputFile.base64Data,
						mimeType: outputFile.mimetype,
						fileExtension: outputFile.extension,
						fileName: outputFile.filename,
					};
				}
			}
		}

		// Add binary script file for Export mode
		if (debugMode === 'export' && debugInfo) {
			const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
			const filename = `python_script_${timestamp}.py`;
			const scriptBinary = createScriptBinary(debugInfo.script_content, filename, scriptExportFormat || 'py');
			
			// Create output.json with execution results
			const outputJsonFilename = `output_${timestamp}.json`;
			const outputJsonBinary = createOutputJsonBinary(baseResult, outputJsonFilename);
			
			// Add binary data to each result item
			for (const resultItem of resultWithPassThrough) {
				if (!resultItem.binary) {
					resultItem.binary = {};
				}
				Object.assign(resultItem.binary, scriptBinary);
				Object.assign(resultItem.binary, outputJsonBinary);
			}
		}

		// Add binary files for Full Debug+ mode
		if (debugMode === 'full_plus' && debugInfo && fullDebugPlusDiagnostics) {
			const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
			
			// Create Python script file
			const scriptFilename = `full_debug_plus_script_${timestamp}.py`;
			const scriptBinary = createScriptBinary(debugInfo.script_content, scriptFilename, scriptExportFormat || 'py');
			
			// Create full diagnostics JSON file (includes all Full Debug+ data)
			const diagnosticsFilename = `full_debug_plus_diagnostics_${timestamp}.json`;
			const diagnosticsBinary = createFullDebugPlusDiagnosticsBinary(fullDebugPlusDiagnostics, baseResult, diagnosticsFilename);
			
			// Add binary data to each result item
			for (const resultItem of resultWithPassThrough) {
				if (!resultItem.binary) {
					resultItem.binary = {};
				}
				Object.assign(resultItem.binary, scriptBinary);
				Object.assign(resultItem.binary, diagnosticsBinary);
			}
		}

		// If successful, return result
		if (exitCode === 0) {
			// Full Debug+: Add final summary and troubleshooting hints
			if (fullDebugPlusDiagnostics) {
				fullDebugPlusDiagnostics.timestamp_end = new Date().toISOString();
				fullDebugPlusDiagnostics.total_duration_ms = 
					new Date(fullDebugPlusDiagnostics.timestamp_end).getTime() - 
					new Date(fullDebugPlusDiagnostics.timestamp_start).getTime();
				
			// Update final summary
			fullDebugPlusDiagnostics.final_summary = {
				data_sources_loaded: [
					injectInputVariables ? 'input_variables' : '',
					Object.keys(pythonEnvVars).length > 0 ? 'credentials' : '',
					systemEnvVars.length > 0 ? 'system_environment' : '',
				].filter(Boolean),
				total_variables_injected: Object.keys(pythonEnvVars).length + (injectInputVariables ? unwrapJsonField(items).length : 0),
				script_executed: true,
				execution_successful: true,
				output_branch: 'success',
			};
			
			// Add troubleshooting hints
			const hints: string[] = [];
			hints.push('‚úì Script executed successfully');
			if (Object.keys(pythonEnvVars).length > 0) {
				hints.push('‚úì Credentials loaded successfully');
			} else {
				hints.push('‚ö† No credentials loaded');
			}
			if (injectInputVariables && unwrapJsonField(items).length > 0) {
				hints.push('‚úì Input variables loaded successfully');
			}
				fullDebugPlusDiagnostics.troubleshooting_hints = hints;
				
				// Add to result
				resultWithPassThrough[0].json.full_debug_plus_diagnostics = fullDebugPlusDiagnostics;
				
				console.log('üî¨ Full Debug+ Diagnostics Complete:', {
					total_duration_ms: fullDebugPlusDiagnostics.total_duration_ms,
					execution_successful: true,
					data_sources_loaded: fullDebugPlusDiagnostics.final_summary.data_sources_loaded,
					troubleshooting_hints: hints,
				});
			}
			
			return [resultWithPassThrough, []];
		}

		// Parse Python error
		const pythonError = parsePythonError(stderr);

		// Full Debug+: Finalize diagnostics for error case
		if (fullDebugPlusDiagnostics) {
			fullDebugPlusDiagnostics.timestamp_end = new Date().toISOString();
			fullDebugPlusDiagnostics.total_duration_ms = 
				new Date(fullDebugPlusDiagnostics.timestamp_end).getTime() - 
				new Date(fullDebugPlusDiagnostics.timestamp_start).getTime();
			
			fullDebugPlusDiagnostics.final_summary = {
				data_sources_loaded: fullDebugPlusDiagnostics.final_summary.data_sources_loaded,
				total_variables_injected: fullDebugPlusDiagnostics.final_summary.total_variables_injected,
				script_executed: true,
				execution_successful: false,
				output_branch: 'error',
			};
			
			fullDebugPlusDiagnostics.troubleshooting_hints = [
				`Script failed with exit code ${exitCode}`,
				`Check Python error traceback in stderr`,
				`Review script_generation.assembled_script for syntax issues`,
				`Verify all required Python modules are installed`,
			];
		}

		// Add error details to result
		baseResult.pythonError = pythonError;
		baseResult.detailedError = `Script failed with exit code ${exitCode}. ${pythonError.errorType || 'Error'}: ${pythonError.errorMessage || stderr}`;
		
		// Process output files even for errors if enabled
		if (outputFileProcessingOptions?.enabled && outputDir) {
			try {
				const outputFiles = await scanOutputDirectory(outputDir, outputFileProcessingOptions);
				baseResult.outputFiles = outputFiles;
				baseResult.outputFilesCount = outputFiles.length;
				console.log(`Found ${outputFiles.length} output files for error case`);
		} catch (error) {
				console.error('Error processing output files in error case:', error);
				baseResult.outputFileError = `Failed to process output files: ${(error as Error).message}`;
			}
		}

		// Add debug information if enabled
		if (debugInfo && debugMode !== 'off') {
			debugInfo.timing = debugTiming;
			addDebugInfoToResult(baseResult, debugInfo, debugMode);
		}

		// Add Full Debug+ diagnostics for error case
		if (debugMode === 'full_plus' && fullDebugPlusDiagnostics) {
			baseResult.full_debug_plus = fullDebugPlusDiagnostics;
			console.log('‚úÖ Full Debug+ diagnostics added to ERROR result');
		}

		// Handle pass through data
		const errorResultWithPassThrough = handlePassThroughData(baseResult, items, passThrough, passThroughMode);

		// Add output files as binary data for errors if enabled
		if (outputFileProcessingOptions?.enabled && baseResult.outputFiles && Array.isArray(baseResult.outputFiles)) {
			for (const resultItem of errorResultWithPassThrough) {
				for (const outputFile of baseResult.outputFiles as OutputFileInfo[]) {
					if (!resultItem.binary) {
						resultItem.binary = {};
					}
					resultItem.binary[outputFile.binaryKey] = {
						data: outputFile.base64Data,
						mimeType: outputFile.mimetype,
						fileExtension: outputFile.extension,
						fileName: outputFile.filename,
					};
				}
			}
		}

		// Add binary script file for Export mode (even for errors)
		if (debugMode === 'export' && debugInfo) {
			const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
			const filename = `python_script_error_${timestamp}.py`;
			const scriptBinary = createScriptBinary(debugInfo.script_content, filename, scriptExportFormat || 'py');
			
			// Create output.json with error results
			const outputJsonFilename = `output_error_${timestamp}.json`;
			const outputJsonBinary = createOutputJsonBinary(baseResult, outputJsonFilename);
			
			for (const resultItem of errorResultWithPassThrough) {
				if (!resultItem.binary) {
					resultItem.binary = {};
				}
				Object.assign(resultItem.binary, scriptBinary);
				Object.assign(resultItem.binary, outputJsonBinary);
			}
		}

		// Add binary files for Full Debug+ mode (even for errors)
		if (debugMode === 'full_plus' && debugInfo && fullDebugPlusDiagnostics) {
			const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
			
			// Create Python script file
			const scriptFilename = `full_debug_plus_script_error_${timestamp}.py`;
			const scriptBinary = createScriptBinary(debugInfo.script_content, scriptFilename, scriptExportFormat || 'py');
			
			// Create full diagnostics JSON file (includes all Full Debug+ data + error info)
			const diagnosticsFilename = `full_debug_plus_diagnostics_error_${timestamp}.json`;
			const diagnosticsBinary = createFullDebugPlusDiagnosticsBinary(fullDebugPlusDiagnostics, baseResult, diagnosticsFilename);
			
			// Add binary data to each result item
			for (const resultItem of errorResultWithPassThrough) {
				if (!resultItem.binary) {
					resultItem.binary = {};
				}
				Object.assign(resultItem.binary, scriptBinary);
				Object.assign(resultItem.binary, diagnosticsBinary);
			}
			
			console.log('‚úÖ Full Debug+ files exported for ERROR result');
		}

		// Return error details or throw
		if (errorHandling === 'details') {
			console.log('Returning error details:', baseResult);
			return [[], errorResultWithPassThrough];
		} else if (errorHandling === 'throw') {
			throw new NodeOperationError(executeFunctions.getNode(), baseResult.detailedError as string);
			} else {
			// 'ignore' mode - return error details but continue execution
			console.log('Ignoring exit code error:', baseResult);
			return [[], errorResultWithPassThrough];
		}

	} catch (error) {
		const errorMessage = (error as Error).message || String(error);
		const pythonErrorInfo = parsePythonError(errorMessage);
		
		if (errorHandling !== 'throw' || executeFunctions.continueOnFail()) {
		const errorItem: IDataObject = {
			exitCode: -1,
			stdout: '',
			stderr: errorMessage,
			success: false,
			error: errorMessage,
			inputItemsCount: items.length,
			executedAt: new Date().toISOString(),
			includeInputVariables: injectInputVariables,
			executionMode: 'once',
			pythonError: pythonErrorInfo,
			detailedError: `System error: ${errorMessage}`,
		};

			// Add debug information if enabled
			if (debugInfo && debugMode !== 'off') {
				debugInfo.timing = debugTiming;
				addDebugInfoToResult(errorItem, debugInfo, debugMode);
			}

			const errorResultWithPassThrough = handlePassThroughData(errorItem, items, passThrough, passThroughMode);

			// Add binary script file for Export mode (even for system errors)
			if (debugMode === 'export' && debugInfo) {
				const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
				const filename = `python_script_system_error_${timestamp}.py`;
				const scriptBinary = createScriptBinary(debugInfo.script_content, filename, scriptExportFormat || 'py');
				
				// Create output.json with system error results
				const outputJsonFilename = `output_system_error_${timestamp}.json`;
				const outputJsonBinary = createOutputJsonBinary(errorItem, outputJsonFilename);
				
				for (const resultItem of errorResultWithPassThrough) {
					if (!resultItem.binary) {
						resultItem.binary = {};
					}
					Object.assign(resultItem.binary, scriptBinary);
					Object.assign(resultItem.binary, outputJsonBinary);
				}
			}

			return [[], errorResultWithPassThrough];
		} else {
				throw error;
		}
	} finally {
		// Full Debug+: Update cleanup diagnostics
		if (fullDebugPlusDiagnostics) {
			fullDebugPlusDiagnostics.execution.cleanup.attempted = true;
			fullDebugPlusDiagnostics.execution.cleanup.files_removed = [scriptPath];
			if (executionDir) {
				fullDebugPlusDiagnostics.execution.cleanup.files_removed.push(executionDir);
			}
		}
		
		try {
		await cleanupScript(scriptPath);
			// Cleanup execution directory completely
			if (executionDir) {
				await cleanupExecutionDirectory(executionDir);
			}
			
			// Full Debug+: Update cleanup success
			if (fullDebugPlusDiagnostics) {
				fullDebugPlusDiagnostics.execution.cleanup.successful = true;
				console.log('üßπ Cleanup successful');
			}
		} catch (cleanupError) {
			// Full Debug+: Update cleanup error
			if (fullDebugPlusDiagnostics) {
				fullDebugPlusDiagnostics.execution.cleanup.successful = false;
				fullDebugPlusDiagnostics.execution.cleanup.error = (cleanupError as Error).message;
				fullDebugPlusDiagnostics.errors_and_warnings.warnings.push(`Cleanup failed: ${(cleanupError as Error).message}`);
				console.log('‚ö† Cleanup failed:', cleanupError);
			}
		}
	}
}


async function executePerItem(
	executeFunctions: IExecuteFunctions,
	functionCode: string,
	pythonPath: string,
	executionTimeout: number,
	injectInputVariables: boolean,
	errorHandling: string,
	debugMode: string,
	parseOutput: string,
	parseOptions: ParseOptions,
	passThrough: boolean,
	passThroughMode: string,
	items: INodeExecutionData[],
	pythonEnvVars: Record<string, string>,
	includeInputItems: boolean,
	includeEnvVarsDict: boolean,
	hideVariableValues: boolean,
	systemEnvVars: string[],
	credentialSources: Record<string, string>,
	inputFiles: FileMapping[],
	outputDir?: string,
	outputFileProcessingOptions?: OutputFileProcessingOptions,
	fileDebugOptions?: FileDebugOptions,
	scriptExportFormat?: string,
): Promise<INodeExecutionData[][]> {
	
	const successResults: INodeExecutionData[] = [];
	const errorResults: INodeExecutionData[] = [];

	for (let i = 0; i < items.length; i++) {
		const item = items[i];
		let scriptPath = '';
		let executionDir = '';
		
		// Create debug timing for each item
		const debugTiming: DebugTiming = {
			script_created_at: new Date().toISOString(),
		};
		let debugInfo: DebugInfo | null = null;
		
		try {
			// Create execution directory for this item
			executionDir = createExecutionDirectory();
			
			// Always call getTemporaryScriptPath to ensure reserved variables are defined
			// Pass empty arrays/objects when injectInputVariables is false
			scriptPath = await getTemporaryScriptPath(
				functionCode, 
				injectInputVariables ? [unwrapJsonField([item])[0]] : [], 
				pythonEnvVars, 
				includeInputItems, 
				includeEnvVarsDict, 
				hideVariableValues, 
				credentialSources, 
				inputFiles, 
				outputDir, 
				outputFileProcessingOptions
			);
				
				// Add output_dir to environment variables if Output File Processing is enabled
				if (outputDir) {
					pythonEnvVars.output_dir = outputDir;
					if (outputFileProcessingOptions?.expectedFileName) {
						pythonEnvVars.expected_filename = outputFileProcessingOptions.expectedFileName;
					}
					pythonEnvVars.output_file_path = outputDir + (outputFileProcessingOptions?.expectedFileName ? `/${outputFileProcessingOptions.expectedFileName}` : '');
			}
			
			// Move script to execution directory
			const scriptFileName = path.basename(scriptPath);
			const newScriptPath = path.join(executionDir, scriptFileName);
			fs.copyFileSync(scriptPath, newScriptPath);
			fs.unlinkSync(scriptPath); // Remove original script
			scriptPath = newScriptPath;
			
			console.log(`Moved script to execution directory: ${scriptPath}`);

			// Create debug information for this item
			if (debugMode !== 'off') {
				let scriptContent: string;
				
				if (debugMode === 'export') {
					// For export mode, use special function without env_vars
					scriptContent = getScriptCodeForExport(
						functionCode, 
						injectInputVariables ? [unwrapJsonField([item])[0]] : [], 
						inputFiles, 
						outputDir, 
						outputFileProcessingOptions
					);
				} else {
					// For other debug modes, use full function with env_vars
					scriptContent = getScriptCode(
						functionCode, 
						injectInputVariables ? [unwrapJsonField([item])[0]] : [], 
						pythonEnvVars, 
						includeInputItems, 
						includeEnvVarsDict, 
						hideVariableValues, 
						credentialSources, 
						inputFiles || [], 
						outputDir || '', 
						outputFileProcessingOptions
					);
				}
				
				debugInfo = await createDebugInfo(
					scriptPath,
					scriptContent,
					pythonPath,
					injectInputVariables ? [unwrapJsonField([item])[0]] : undefined,
					(injectInputVariables && debugMode !== 'export') ? pythonEnvVars : undefined,
					debugTiming,
					credentialSources,
				);
			}
			
		} catch (error) {
			// Cleanup execution directory if script creation failed
			if (executionDir) {
				await cleanupExecutionDirectory(executionDir);
			}
			
			if (errorHandling === 'details' || executeFunctions.continueOnFail()) {
				const errorResult: IDataObject = {
					exitCode: -1,
					stdout: '',
					stderr: `Could not generate script: ${(error as Error).message}`,
					success: false,
					error: `Script generation failed: ${(error as Error).message}`,
					inputItemsCount: 1,
					executedAt: new Date().toISOString(),
					includeInputVariables: injectInputVariables,
					parseOutput,
					executionMode: 'perItem',
					itemIndex: i,
				};
				
				// Add debug information if enabled (for script generation errors)
				if (debugInfo && debugMode !== 'off') {
					debugInfo.timing = debugTiming;
					addDebugInfoToResult(errorResult, debugInfo, debugMode);
				}
				
				const errorWithPassThrough = handlePassThroughData(errorResult, [item], passThrough, passThroughMode);

				// Add binary script file for Export mode (even for generation errors)
				if (debugMode === 'export' && debugInfo) {
					const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
					const filename = `python_script_item_${i}_gen_error_${timestamp}.py`;
					const scriptBinary = createScriptBinary(debugInfo.script_content, filename, scriptExportFormat || 'py');
					
					// Create output.json with generation error results
					const outputJsonFilename = `output_item_${i}_gen_error_${timestamp}.json`;
					const outputJsonBinary = createOutputJsonBinary(errorResult, outputJsonFilename);
					
					for (const resultItem of errorWithPassThrough) {
						if (!resultItem.binary) {
							resultItem.binary = {};
						}
						Object.assign(resultItem.binary, scriptBinary);
						Object.assign(resultItem.binary, outputJsonBinary);
					}
				}

				errorResults.push(...errorWithPassThrough);
				continue;
			} else {
				throw new NodeOperationError(executeFunctions.getNode(), `Could not generate temporary script file: ${(error as Error).message}`);
			}
		}

		// For Test Only mode, return validation results without execution
		if (debugMode === 'test') {
			const testResult: IDataObject = {
				exitCode: null,
				stdout: '',
				stderr: '',
				success: null,
				error: null,
				inputItemsCount: 1,
				executedAt: new Date().toISOString(),
				includeInputVariables: injectInputVariables,
				parseOutput,
				executionMode: 'perItem',
				itemIndex: i,
				test_mode: true,
				execution_skipped: true,
			};

			if (debugInfo) {
				addDebugInfoToResult(testResult, debugInfo, debugMode);
			}

			const testResultWithPassThrough = handlePassThroughData(testResult, [item], passThrough, passThroughMode);
			successResults.push(...testResultWithPassThrough);
			continue;
		}

		try {
			// Execute the Python script for this item
			debugTiming.execution_started_at = new Date().toISOString();
			const execResults = await execPythonSpawn(scriptPath, pythonPath, executionDir, executionTimeout, executeFunctions.sendMessageToUI);
			debugTiming.execution_finished_at = new Date().toISOString();
			debugTiming.total_duration_ms = new Date(debugTiming.execution_finished_at).getTime() - 
				new Date(debugTiming.execution_started_at).getTime();

			const {
				error: returnedError,
				exitCode,
				stdout,
				stderr,
			} = execResults;

			// Parse stdout based on configuration
			let parseResult: ParseResult | null = null;
			if (parseOutput !== 'none') {
				parseResult = parseStdout(stdout, parseOutput, parseOptions);
			}

			// Base result object for this item
			const itemResult: IDataObject = {
				exitCode,
				stdout,
				stderr,
				success: exitCode === 0,
				error: exitCode === 0 ? null : 'Script execution failed',
				inputItemsCount: 1,
				executedAt: new Date().toISOString(),
				includeInputVariables: injectInputVariables,
				parseOutput,
				executionMode: 'perItem',
				itemIndex: i,
			};

			// Add parsing results if enabled
			if (parseResult) {
				Object.assign(itemResult, {
					parsed_stdout: parseResult.parsed_stdout,
					parsing_success: parseResult.parsing_success,
					parsing_error: parseResult.parsing_error,
					output_format: parseResult.output_format,
					parsing_method: parseResult.parsing_method,
				});
			}

			// Process output files if enabled
			if (outputFileProcessingOptions?.enabled && outputDir) {
				try {
					const outputFiles = await scanOutputDirectory(outputDir, outputFileProcessingOptions);
					
					// Add output file information to result
					itemResult.outputFiles = outputFiles;
					itemResult.outputFilesCount = outputFiles.length;
					
					console.log(`Found ${outputFiles.length} output files for item ${i}`);
				} catch (error) {
					console.error(`Error processing output files for item ${i}:`, error);
					itemResult.outputFileError = `Failed to process output files: ${(error as Error).message}`;
				}
			}

			// Add file debug information if enabled
			if (fileDebugOptions?.enabled) {
				try {
					const fileDebugInfo = await createFileDebugInfo(
						inputFiles,
						outputDir,
						outputFileProcessingOptions,
						fileDebugOptions,
					);
					itemResult.fileDebugInfo = fileDebugInfo;
					console.log(`File debug information added to result for item ${i}`);
				} catch (error) {
					console.error(`Error creating file debug info for item ${i}:`, error);
					itemResult.fileDebugError = `Failed to create file debug info: ${(error as Error).message}`;
				}
			}

			// Handle errors
			if (exitCode !== 0) {
				const pythonError = parsePythonError(stderr);
				itemResult.pythonError = pythonError;
				itemResult.detailedError = `Script failed with exit code ${exitCode}. ${pythonError.errorType || 'Error'}: ${pythonError.errorMessage || stderr}`;
				
				// Full Debug+: Finalize diagnostics for error case
				if (debugMode === 'full_plus' && debugInfo) {
					// Note: fullDebugPlusDiagnostics is not available in executePerItem
					// We'll add basic error info to debugInfo instead
					debugInfo.error_info = {
						exit_code: exitCode,
						python_error: pythonError,
						error_timestamp: new Date().toISOString(),
					};
				}
				
				if (errorHandling === 'throw') {
					throw new NodeOperationError(executeFunctions.getNode(), itemResult.detailedError as string);
				}
				// For 'details' and 'ignore' modes, continue with the error info in result
			}

			// Add debug information if enabled
			if (debugInfo && debugMode !== 'off') {
				debugInfo.timing = debugTiming;
				addDebugInfoToResult(itemResult, debugInfo, debugMode);
			}

			// Handle pass through data
			const resultWithPassThrough = handlePassThroughData(itemResult, [item], passThrough, passThroughMode);

			// Add output files as binary data if enabled
			if (outputFileProcessingOptions?.enabled && itemResult.outputFiles && Array.isArray(itemResult.outputFiles)) {
				for (const resultItem of resultWithPassThrough) {
					for (const outputFile of itemResult.outputFiles as OutputFileInfo[]) {
						if (!resultItem.binary) {
							resultItem.binary = {};
						}
						resultItem.binary[outputFile.binaryKey] = {
							data: outputFile.base64Data,
							mimeType: outputFile.mimetype,
							fileExtension: outputFile.extension,
							fileName: outputFile.filename,
						};
					}
				}
			}

			// Add binary script file for Export mode
			if (debugMode === 'export' && debugInfo) {
				const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
				const filename = `python_script_item_${i}_${timestamp}.py`;
				const scriptBinary = createScriptBinary(debugInfo.script_content, filename, scriptExportFormat || 'py');
				
				// Create output.json with execution results for this item
				const outputJsonFilename = `output_item_${i}_${timestamp}.json`;
				const outputJsonBinary = createOutputJsonBinary(itemResult, outputJsonFilename);
				
				for (const resultItem of resultWithPassThrough) {
					if (!resultItem.binary) {
						resultItem.binary = {};
					}
					Object.assign(resultItem.binary, scriptBinary);
					Object.assign(resultItem.binary, outputJsonBinary);
				}
			}

			// Add binary script file for Full Debug+ mode (per-item mode)
			if (debugMode === 'full_plus' && debugInfo) {
				const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
				const scriptFilename = `full_debug_plus_script_item_${i}_${timestamp}.py`;
				const scriptBinary = createScriptBinary(debugInfo.script_content, scriptFilename, scriptExportFormat || 'py');
				
				// Create output.json with execution results for this item
				const outputJsonFilename = `full_debug_plus_output_item_${i}_${timestamp}.json`;
				const outputJsonBinary = createOutputJsonBinary(itemResult, outputJsonFilename);
				
				for (const resultItem of resultWithPassThrough) {
					if (!resultItem.binary) {
						resultItem.binary = {};
					}
					Object.assign(resultItem.binary, scriptBinary);
					Object.assign(resultItem.binary, outputJsonBinary);
				}
			}

			// Add to appropriate results array based on exit code
			if (exitCode === 0) {
				successResults.push(...resultWithPassThrough);
			} else {
				errorResults.push(...resultWithPassThrough);
			}

		} catch (error) {
			// Cleanup execution directory if execution failed
			if (executionDir) {
				await cleanupExecutionDirectory(executionDir);
			}
			
			if (errorHandling !== 'throw' || executeFunctions.continueOnFail()) {
				const errorMessage = (error as Error).message || String(error);
				const pythonErrorInfo = parsePythonError(errorMessage);
				
				const errorResult: IDataObject = {
					exitCode: -1,
					stdout: '',
					stderr: errorMessage,
					success: false,
					error: errorMessage,
					inputItemsCount: 1,
					executedAt: new Date().toISOString(),
					includeInputVariables: injectInputVariables,
					parseOutput,
					executionMode: 'perItem',
					itemIndex: i,
					pythonError: pythonErrorInfo,
					detailedError: `System error: ${errorMessage}`,
				};

				// Add debug information if enabled
				if (debugInfo && debugMode !== 'off') {
					debugInfo.timing = debugTiming;
					addDebugInfoToResult(errorResult, debugInfo, debugMode);
				}

				const errorWithPassThrough = handlePassThroughData(errorResult, [item], passThrough, passThroughMode);

				// Add binary script file for Export mode (even for system errors)
				if (debugMode === 'export' && debugInfo) {
					const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
					const filename = `python_script_item_${i}_error_${timestamp}.py`;
					const scriptBinary = createScriptBinary(debugInfo.script_content, filename, scriptExportFormat || 'py');
					
					// Create output.json with system error results for this item
					const outputJsonFilename = `output_item_${i}_error_${timestamp}.json`;
					const outputJsonBinary = createOutputJsonBinary(errorResult, outputJsonFilename);
					
					for (const resultItem of errorWithPassThrough) {
						if (!resultItem.binary) {
							resultItem.binary = {};
						}
						Object.assign(resultItem.binary, scriptBinary);
						Object.assign(resultItem.binary, outputJsonBinary);
					}
				}

				errorResults.push(...errorWithPassThrough);
			} else {
				throw error;
			}
		} finally {
			await cleanupScript(scriptPath);
			// Cleanup execution directory completely
			if (executionDir) {
				await cleanupExecutionDirectory(executionDir);
			}
		}
	}

	return [successResults, errorResults];
}


function execPythonSpawn(scriptPath: string, pythonPath: string, executionDir: string, timeoutMinutes: number, stdoutListener?: CallableFunction): Promise<IExecReturnData> {
	const returnData: IExecReturnData = {
		error: undefined,
		exitCode: 0,
		stderr: '',
		stdout: '',
	};
	
	return new Promise((resolve, reject) => {
		const child = spawn(pythonPath, [scriptPath], {
			cwd: executionDir,
		});

		// Set up timeout
		const timeoutMs = timeoutMinutes * 60 * 1000; // Convert minutes to milliseconds
		const timeoutId = setTimeout(() => {
			console.log(`Script execution timeout after ${timeoutMinutes} minutes, killing process`);
			child.kill('SIGKILL'); // Force kill the process
			returnData.exitCode = -2;
			returnData.error = new Error(`Script execution timeout after ${timeoutMinutes} minutes`);
			returnData.stderr += `\n[Timeout] Process killed after ${timeoutMinutes} minutes`;
			resolve(returnData);
		}, timeoutMs);

		child.stdout.on('data', data => {
			returnData.stdout += data.toString();
			if (stdoutListener) {
				stdoutListener(data.toString());
			}
		});

		child.stderr.on('data', data => {
			returnData.stderr += data.toString();
		});

		child.on('error', (error) => {
			clearTimeout(timeoutId);
			returnData.error = error;
			resolve(returnData);
		});

		child.on('close', code => {
			clearTimeout(timeoutId);
			returnData.exitCode = code || 0;
			if (code !== 0) {
				returnData.error = new Error(`Process exited with code ${code}`);
			}
			resolve(returnData);
		});
	});
}


function parseEnvFile(envFileContent: string): Record<string, string> {
	const envVars: Record<string, string> = {};
	const lines = envFileContent.split('\n');
	
	for (const line of lines) {
		const trimmedLine = line.trim();
		if (trimmedLine && !trimmedLine.startsWith('#')) {
			const equalIndex = trimmedLine.indexOf('=');
			if (equalIndex > 0) {
				const key = trimmedLine.substring(0, equalIndex).trim();
				const value = trimmedLine.substring(equalIndex + 1).trim();
				envVars[key] = value;
			}
		}
	}
	
	return envVars;
}

/**
 * Convert JavaScript/JSON values to Python-compatible string representation
 * Handles boolean conversion (true/false -> True/False) and other Python-specific formatting
 */
function convertToPythonValue(value: unknown): string {
	if (value === null) {
		return 'None';
	}
	
	if (typeof value === 'boolean') {
		return value ? 'True' : 'False';
	}
	
	if (typeof value === 'undefined') {
		return 'None';
	}
	
	if (typeof value === 'string') {
		return JSON.stringify(value);
	}
	
	if (typeof value === 'number') {
		return String(value);
	}
	
	if (Array.isArray(value)) {
		const pythonArray = value.map(item => convertToPythonValue(item));
		return `[${pythonArray.join(', ')}]`;
	}
	
	if (typeof value === 'object' && value !== null) {
		const entries = Object.entries(value as Record<string, unknown>);
		const pythonDict = entries.map(([key, val]) => {
			const pythonKey = JSON.stringify(key);
			const pythonVal = convertToPythonValue(val);
			return `${pythonKey}: ${pythonVal}`;
		});
		return `{${pythonDict.join(', ')}}`;
	}
	
	// Fallback to JSON.stringify for other types
	return JSON.stringify(value);
}

function sanitizeVariableName(key: string, prefix = 'var'): string | null {
	// Skip empty keys or invalid Python identifiers
	if (!key || key.trim() === '') {
		return null;
	}
	
	// Create safe variable names (replace invalid characters)
	let safeVarName = key.replace(/[^a-zA-Z0-9_]/g, '_');
	
	// Ensure it starts with letter or underscore
	if (!/^[a-zA-Z_]/.test(safeVarName)) {
		safeVarName = `${prefix}_${safeVarName}`;
	}
	
	// Skip if after sanitization the name is empty or invalid
	if (!safeVarName || safeVarName.trim() === '' || safeVarName === `${prefix}_`) {
		return null;
	}
	
	return safeVarName;
}

function formatCodeSnippet(code: string): string {
	// add tab at the beginning of each line
	return code
		.replace(/\n/g, '\n\t')
		.replace(/\r/g, '\n\t')
		.replace(/\r\n\t/g, '\n\t')
		.replace(/\r\n/g, '\n\t');
}

function getScriptCodeForExport(
	codeSnippet: string, 
	data: IDataObject[], 
	inputFiles?: FileMapping[],
	outputDir?: string,
	outputFileOptions?: { expectedFileName?: string; fileDetectionMode?: string },
): string {
	const path = require('path');
	const fs = require('fs');
	
	// Extract __future__ imports from the beginning of the code
	const futureImportRegex = /^from __future__ import .+$/gm;
	const futureImports: string[] = [];
	let match = futureImportRegex.exec(codeSnippet);
	let cleanedCodeSnippet = codeSnippet;
	
	while (match !== null) {
		futureImports.push(match[0].trim());
		match = futureImportRegex.exec(codeSnippet);
	}
	
	// Remove __future__ imports from the original code
	cleanedCodeSnippet = codeSnippet.replace(futureImportRegex, '').trim();
	
	// Extract individual variables from the first item if available
	let individualVariables = '';
	if (data.length > 0) {
		const firstItem = data[0];
		const variableAssignments: string[] = [];
		
		for (const [key, value] of Object.entries(firstItem)) {
			const safeVarName = sanitizeVariableName(key, 'var');
			
			// Skip if sanitization failed
			if (!safeVarName) {
				continue;
			}
			
			const displayValue = convertToPythonValue(value);
			variableAssignments.push(`${safeVarName} = ${displayValue}`);
		}
		
		if (variableAssignments.length > 0) {
			individualVariables = `
# Individual variables from first input item
${variableAssignments.join('\n')}
`;
		}
	}

	// Add input files array if files are provided
	let inputFilesSection = '';
	if (inputFiles && inputFiles.length > 0) {
		const filesArray = inputFiles.map(file => {
			const fileInfo: Record<string, unknown> = {
				filename: file.filename,
				mimetype: file.mimetype,
				size: file.size,
				extension: file.extension,
				binary_key: file.binaryKey,
				item_index: file.itemIndex,
			};
			
			if (file.tempPath) {
				fileInfo.temp_path = file.tempPath;
			}
			
			if (file.base64Data) {
				fileInfo.base64_data = file.base64Data;
			}
			
			return fileInfo;
		});
		
		const filesValue = convertToPythonValue(filesArray);
		inputFilesSection = `
# Binary files from previous nodes
input_files = ${filesValue}`;
	}

	// Add output directory section if provided
	let outputDirSection = '';
	if (outputDir) {
		// Output file variables should never be hidden as they are essential for functionality
		const outputDirValue = outputDir;
		let outputFileInstructions = '';
		let outputFilePathVariable = '';
		let expectedFileNameVariable = '';
		
		// Add expected filename variable if configured
		if (outputFileOptions?.expectedFileName) {
			const expectedFileNameValue = outputFileOptions.expectedFileName;
			expectedFileNameVariable = `expected_filename = "${expectedFileNameValue}"`;
		}
		
		// Add expected file path variable if configured
		if (outputFileOptions?.expectedFileName && outputFileOptions?.fileDetectionMode === 'variable_path') {
			const expectedFilePath = path.join(outputDir, outputFileOptions.expectedFileName);
			const outputFilePathValue = expectedFilePath;
			outputFilePathVariable = `output_file_path = r"${outputFilePathValue}"`;
			
			outputFileInstructions = `# üìÅ Ready Variable Path Mode:
# Two ways to create your output file:
# 
# Method 1 (Recommended): Use ready-made full path
# with open(output_file_path, 'w') as f:
#     f.write("your content")
#
# Method 2: Build path manually using expected filename
# import os
# file_path = os.path.join(output_dir, expected_filename)
# with open(file_path, 'w') as f:
#     f.write("your content")
#
# Expected filename: ${outputFileOptions.expectedFileName}
# n8n will automatically detect and process this file after script execution
`;
		} else if (outputFileOptions?.expectedFileName && outputFileOptions?.fileDetectionMode === 'auto_search') {
			outputFileInstructions = `# üîç Auto Search Mode:
# Create a file with the exact filename specified in expected_filename variable
# You can save it anywhere (current directory, subdirectories, etc.)
# n8n will automatically search and find this file after script execution
#
# Recommended usage:
# with open(expected_filename, 'w') as f:
#     f.write("your content")
#
# Alternative with full path:
# import os
# file_path = os.path.join(output_dir, expected_filename)  
# with open(file_path, 'w') as f:
#     f.write("your content")
#
# Expected filename: ${outputFileOptions.expectedFileName}
`;
		} else {
			outputFileInstructions = `# üìÅ Manual Output File Processing:
# Save your files in the output_dir directory
# Example: 
#   import os
#   file_path = os.path.join(output_dir, "my_file.txt")
#   with open(file_path, 'w') as f: f.write("your content")
`;
		}
		
		outputDirSection = `
# Output directory for generated files (Output File Processing enabled)
output_dir = r"${outputDirValue}"
${expectedFileNameVariable}
${outputFilePathVariable}

${outputFileInstructions}`;
	}

	const script = `#!/usr/bin/env python3
# Auto-generated script for n8n Python Function (Raw)
${futureImports.length > 0 ? futureImports.join('\n') + '\n' : ''}
import json
import sys
${individualVariables}${inputFilesSection}${outputDirSection}
# User code starts here
${cleanedCodeSnippet}
`;

	return script;
}

function getScriptCode(
	codeSnippet: string, 
	data: IDataObject[], 
	envVars: Record<string, string>, 
	includeInputItems = true, 
	includeEnvVarsDict = false, 
	hideVariableValues = false,
	credentialSources?: Record<string, string>,
	inputFiles?: FileMapping[],
	outputDir?: string,
	outputFileOptions?: { expectedFileName?: string; fileDetectionMode?: string },
): string {
	const path = require('path');
	const fs = require('fs');
	
	// Extract __future__ imports from the beginning of the code
	const futureImportRegex = /^from __future__ import .+$/gm;
	const futureImports: string[] = [];
	let match = futureImportRegex.exec(codeSnippet);
	let cleanedCodeSnippet = codeSnippet;
	
	while (match !== null) {
		futureImports.push(match[0].trim());
		match = futureImportRegex.exec(codeSnippet);
	}
	
	// Remove __future__ imports from the original code
	cleanedCodeSnippet = codeSnippet.replace(futureImportRegex, '').trim();
	
	// Extract individual variables from the first item if available
	let individualVariables = '';
	if (data.length > 0) {
		const firstItem = data[0];
		const variableAssignments: string[] = [];
		
		for (const [key, value] of Object.entries(firstItem)) {
			const safeVarName = sanitizeVariableName(key, 'var');
			
			// Skip if sanitization failed
			if (!safeVarName) {
				continue;
			}
			
			const displayValue = hideVariableValues ? '"***hidden***"' : convertToPythonValue(value);
			variableAssignments.push(`${safeVarName} = ${displayValue}`);
		}
		
		if (variableAssignments.length > 0) {
			individualVariables = `
# Individual variables from first input item
${variableAssignments.join('\n')}
`;
		}
	}

	// Add environment variables as individual Python variables with source information
	let envVariablesSection = '';
	if (Object.keys(envVars).length > 0) {
		const envVariableAssignments: string[] = [];
		
		// Group variables by source for better organization
		const variablesBySource: Record<string, string[]> = {};
		
		for (const [key, value] of Object.entries(envVars)) {
			const safeVarName = sanitizeVariableName(key, 'env');
			
			// Skip if sanitization failed
			if (!safeVarName) {
				continue;
			}
			
			const displayValue = hideVariableValues ? '"***hidden***"' : convertToPythonValue(value);
			const assignment = `${safeVarName} = ${displayValue}`;
			
			// Get source information
			const source = credentialSources?.[key] || 'unknown_source';
			if (!variablesBySource[source]) {
				variablesBySource[source] = [];
			}
			variablesBySource[source].push(assignment);
		}
		
		// Generate organized section with source comments
		if (credentialSources && Object.keys(variablesBySource).length > 1) {
			for (const [source, assignments] of Object.entries(variablesBySource)) {
				envVariableAssignments.push(`# From: ${source}`);
				envVariableAssignments.push(...assignments);
				envVariableAssignments.push('');
			}
			// Remove last empty line
			if (envVariableAssignments[envVariableAssignments.length - 1] === '') {
				envVariableAssignments.pop();
			}
		} else {
			// Simple list without source grouping
			for (const [key, value] of Object.entries(envVars)) {
				const safeVarName = sanitizeVariableName(key, 'env');
				
				// Skip if sanitization failed
				if (!safeVarName) {
					continue;
				}
				
				const displayValue = hideVariableValues ? '"***hidden***"' : convertToPythonValue(value);
				envVariableAssignments.push(`${safeVarName} = ${displayValue}`);
			}
		}
		
		if (envVariableAssignments.length > 0) {
			envVariablesSection = `
# Environment variables (from credentials and system)
${envVariableAssignments.join('\n')}
`;
		}
	}

	// Reserved variables - always defined (empty if disabled)
	let reservedVariablesSection = '';
	
	// Always define input_items (empty list if not included)
	const inputItemsValue = includeInputItems && data.length > 0 
		? (hideVariableValues ? '"***hidden***"' : convertToPythonValue(data))
		: '[]';
	
	// Always define env_vars (empty dict if not included)
	const envVarsValue = includeEnvVarsDict && Object.keys(envVars).length > 0
		? (hideVariableValues ? '"***hidden***"' : convertToPythonValue(envVars))
		: '{}';
	
	reservedVariablesSection = `
# Reserved variables (always defined)
input_items = ${inputItemsValue}
env_vars = ${envVarsValue}`;

	// Always define input_files (empty list if not provided)
	let inputFilesValue = '[]';
	if (inputFiles && inputFiles.length > 0) {
		const filesArray = inputFiles.map(file => {
			const fileInfo: Record<string, unknown> = {
				filename: file.filename,
				mimetype: file.mimetype,
				size: file.size,
				extension: file.extension,
					binary_key: file.binaryKey,
				item_index: file.itemIndex,
			};
			
			if (file.tempPath) {
				fileInfo.temp_path = hideVariableValues ? '"***hidden***"' : file.tempPath;
			}
			
			if (file.base64Data) {
				fileInfo.base64_data = hideVariableValues ? '"***hidden***"' : file.base64Data;
			}
			
			return fileInfo;
		});
		
		inputFilesValue = hideVariableValues ? '"***hidden***"' : convertToPythonValue(filesArray);
	}
	
	const inputFilesSection = `
input_files = ${inputFilesValue}`;

	// Always define output_dir (empty string if not provided)
	let outputDirValue = '""';
	let expectedFileNameVariable = '';
	let outputFilePathVariable = '';
	let outputFileInstructions = '';
	
	if (outputDir) {
		// Output file variables should never be hidden as they are essential for functionality
		outputDirValue = `r"${outputDir}"`;
		
		// Add expected filename variable if configured
		if (outputFileOptions?.expectedFileName) {
			const expectedFileNameValue = outputFileOptions.expectedFileName;
			expectedFileNameVariable = `expected_filename = "${expectedFileNameValue}"`;
		}
		
		// Add expected file path variable if configured
		if (outputFileOptions?.expectedFileName && outputFileOptions?.fileDetectionMode === 'variable_path') {
			const expectedFilePath = path.join(outputDir, outputFileOptions.expectedFileName);
			const outputFilePathValue = expectedFilePath;
			outputFilePathVariable = `output_file_path = r"${outputFilePathValue}"`;
			
			outputFileInstructions = `# üìÅ Ready Variable Path Mode:
# Two ways to create your output file:
# 
# Method 1 (Recommended): Use ready-made full path
# with open(output_file_path, 'w') as f:
#     f.write("your content")
#
# Method 2: Build path manually using expected filename
# import os
# file_path = os.path.join(output_dir, expected_filename)
# with open(file_path, 'w') as f:
#     f.write("your content")
#
# Expected filename: ${outputFileOptions.expectedFileName}
# n8n will automatically detect and process this file after script execution
`;
		} else if (outputFileOptions?.expectedFileName && outputFileOptions?.fileDetectionMode === 'auto_search') {
			outputFileInstructions = `# üîç Auto Search Mode:
# Create a file with the exact filename specified in expected_filename variable
# You can save it anywhere (current directory, subdirectories, etc.)
# n8n will automatically search and find this file after script execution
#
# Recommended usage:
# with open(expected_filename, 'w') as f:
#     f.write("your content")
#
# Alternative with full path:
# import os
# file_path = os.path.join(output_dir, expected_filename)  
# with open(file_path, 'w') as f:
#     f.write("your content")
#
# Expected filename: ${outputFileOptions.expectedFileName}
`;
		} else {
			outputFileInstructions = `# üìÅ Manual Output File Processing:
# Save your files in the output_dir directory
# Example: 
#   import os
#   file_path = os.path.join(output_dir, "my_file.txt")
#   with open(file_path, 'w') as f: f.write("your content")
`;
		}
		}
		
	const outputDirSection = `
output_dir = ${outputDirValue}
${expectedFileNameVariable}
${outputFilePathVariable}
${outputFileInstructions}`;

	const script = `#!/usr/bin/env python3
# Auto-generated script for n8n Python Function (Raw)
${futureImports.length > 0 ? futureImports.join('\n') + '\n' : ''}
import json
import sys
${envVariablesSection}${individualVariables}${reservedVariablesSection}${inputFilesSection}${outputDirSection}
# User code starts here
${cleanedCodeSnippet}
`;
	return script;
}


async function getTemporaryScriptPath(codeSnippet: string, data: IDataObject[], envVars: Record<string, string>, includeInputItems = true, includeEnvVarsDict = false, hideVariableValues = false, credentialSources?: Record<string, string>, inputFiles?: FileMapping[], outputDir?: string, outputFileOptions?: OutputFileProcessingOptions): Promise<string> {
	const tmpPath = tempy.file({extension: 'py'});
	const codeStr = getScriptCode(codeSnippet, data, envVars, includeInputItems, includeEnvVarsDict, hideVariableValues, credentialSources, inputFiles, outputDir, outputFileOptions);
	
	// Ensure file is overwritten by explicitly writing with 'w' flag
	try {
		// Remove file if it exists
		if (fs.existsSync(tmpPath)) {
			fs.unlinkSync(tmpPath);
		}
		
		// Basic syntax validation for auto-generated variables only
		// Only validate the n8n-generated portion, not user code
		const lines = codeStr.split('\n');
		let userCodeStartIndex = -1;
		
		// Find where user code starts (marked by "# User code starts here")
		for (let i = 0; i < lines.length; i++) {
			if (lines[i].includes('# User code starts here')) {
				userCodeStartIndex = i;
				break;
			}
		}
		
		// Only validate lines before user code starts
		for (let i = 0; i < (userCodeStartIndex > 0 ? userCodeStartIndex : lines.length); i++) {
			const line = lines[i];
			const trimmedLine = line.trim();
			
			// Skip empty lines and comments
			if (!trimmedLine || trimmedLine.startsWith('#')) {
				continue;
			}
			
			// Only check top-level variable assignments that start at column 0
			const assignmentMatch = line.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\s*=\s*/);
			if (assignmentMatch) {
				const varName = assignmentMatch[1];
				
				// Check for invalid variable names in auto-generated section only
				if (!varName || !varName.match(/^[a-zA-Z_][a-zA-Z0-9_]*$/)) {
					throw new Error(`Invalid variable assignment detected at line ${i + 1}: "${line}". This usually happens when input data contains empty keys or invalid field names. Please check your input data structure.`);
				}
			}
		}
		
		// Optional: Pre-validate user code syntax (non-blocking)
		try {
			// Extract just the user code part for validation
			const userCodeStart = codeStr.indexOf('# User code starts here');
			if (userCodeStart !== -1) {
				const userCodeSection = codeStr.substring(userCodeStart + '# User code starts here'.length).trim();
				if (userCodeSection) {
					// Create temporary file for user code validation
					const userTmpPath = tempy.file({extension: 'py'});
					fs.writeFileSync(userTmpPath, userCodeSection, { encoding: 'utf8', flag: 'w' });
					
					// Quick syntax check without blocking execution
					const userValidation = await validatePythonSyntax(userTmpPath, 'python3');
					if (!userValidation.is_valid) {
						console.warn(`User code syntax warning (line ${userValidation.line_number}): ${userValidation.syntax_error}`);
						// Don't throw error - just log warning
					}
					
					// Clean up validation file
					try {
						fs.unlinkSync(userTmpPath);
					} catch (e) {
						// Ignore cleanup errors
					}
				}
			}
		} catch (validationError) {
			console.warn(`User code validation warning: ${(validationError as Error).message}`);
			// Don't throw error - validation is optional
		}
		
		// Write new content
		fs.writeFileSync(tmpPath, codeStr, { encoding: 'utf8', flag: 'w' });
		console.log(`Created temporary script at: ${tmpPath}`);
	} catch (error) {
		throw new Error(`Failed to create script file: ${(error as Error).message}`);
	}
	
	return tmpPath;
}


async function getTemporaryPureScriptPath(codeSnippet: string): Promise<string> {
	const tmpPath = tempy.file({extension: 'py'});
	
	// Ensure file is overwritten by explicitly writing with 'w' flag
	try {
		// Remove file if it exists
		if (fs.existsSync(tmpPath)) {
			fs.unlinkSync(tmpPath);
		}
		// Write pure Python code without any modifications
		fs.writeFileSync(tmpPath, codeSnippet, { encoding: 'utf8', flag: 'w' });
		console.log(`Created temporary pure script at: ${tmpPath}`);
	} catch (error) {
		throw new Error(`Failed to create script file: ${(error as Error).message}`);
	}
	
	return tmpPath;
}


function unwrapJsonField(list: IDataObject[] = []): IDataObject[] {
	return list.reduce((acc, item) => {
		if ('json' in item) {
			acc.push(item.json as never);
		} else {
			acc.push(item as never);
		}
		return acc;
	}, []);
}


interface PythonErrorInfo {
	errorType: string | null;
	errorMessage: string | null;
	missingModules: string[];
	traceback: string | null;
	lineNumber: number | null;
}


interface ParseResult {
	parsed_stdout: unknown;
	parsing_success: boolean;
	parsing_error: string | null;
	output_format: string;
	parsing_method: string;
}


interface ParseOptions {
	multipleJson?: boolean;
	stripNonJson?: boolean;
	fallbackOnError?: boolean;
}


interface DebugTiming {
	script_created_at: string;
	execution_started_at?: string;
	execution_finished_at?: string;
	total_duration_ms?: number;
}

interface DebugInfo {
	script_content: string;
	script_path: string;
	execution_command: string[];
	injected_data?: {
		input_items: IDataObject[];
		env_vars: Record<string, string>;
	};
	timing: DebugTiming;
	python_version?: string;
	environment_check?: {
		python_executable_found: boolean;
		python_version_output?: string;
		python_path_resolved?: string;
	};
	syntax_validation?: {
		is_valid: boolean;
		syntax_error?: string;
		line_number?: number;
	};
	error_info?: {
		exit_code: number;
		python_error: any;
		error_timestamp: string;
	};
}


function parsePythonError(stderr: string): PythonErrorInfo {
	const result: PythonErrorInfo = {
		errorType: null,
		errorMessage: null,
		missingModules: [],
		traceback: null,
		lineNumber: null,
	};

	if (!stderr) {
		return result;
	}

	// Full traceback
	result.traceback = stderr;

	// Extract error type and message
	const errorMatch = stderr.match(/^(\w+(?:Error|Exception)): (.+)$/m);
	if (errorMatch) {
		result.errorType = errorMatch[1];
		result.errorMessage = errorMatch[2];
	}

	// Extract missing modules
	const missingModules = new Set<string>();
	
	// ModuleNotFoundError patterns
	const moduleNotFoundMatches = stderr.matchAll(/ModuleNotFoundError: No module named '([^']+)'/g);
	for (const match of moduleNotFoundMatches) {
		missingModules.add(match[1]);
	}
	
	// ImportError patterns
	const importErrorMatches = stderr.matchAll(/ImportError: No module named '([^']+)'/g);
	for (const match of importErrorMatches) {
		missingModules.add(match[1]);
	}
	
	// ImportError: cannot import name patterns
	const cannotImportMatches = stderr.matchAll(/ImportError: cannot import name '([^']+)' from '([^']+)'/g);
	for (const match of cannotImportMatches) {
		missingModules.add(match[2]); // Add the package name
	}

	result.missingModules = Array.from(missingModules);

	// Extract line number
	const lineMatch = stderr.match(/File ".*", line (\d+)/);
	if (lineMatch) {
		result.lineNumber = parseInt(lineMatch[1], 10);
	}

	return result;
}


function parseStdout(stdout: string, parseMode: string, options: ParseOptions = {}): ParseResult {
	const result: ParseResult = {
		parsed_stdout: stdout,
		parsing_success: false,
		parsing_error: null,
		output_format: 'text',
		parsing_method: parseMode,
	};

	if (!stdout || stdout.trim() === '') {
		result.parsed_stdout = parseMode === 'lines' ? [] : null;
		result.parsing_success = true;
		result.output_format = 'empty';
		return result;
	}

	try {
		switch (parseMode) {
			case 'json':
				return parseAsJson(stdout, options);
			
			case 'lines':
				return parseAsLines(stdout);
			
			case 'smart':
				return parseSmartMode(stdout, options);
			
			default:
				result.parsing_success = true;
				result.output_format = 'text';
				return result;
		}
	} catch (error) {
		result.parsing_error = (error as Error).message;
		if (options.fallbackOnError !== false) {
			result.parsed_stdout = stdout;
		}
		return result;
	}
}


function parseAsJson(stdout: string, options: ParseOptions): ParseResult {
	const result: ParseResult = {
		parsed_stdout: null,
		parsing_success: false,
		parsing_error: null,
		output_format: 'json',
		parsing_method: 'json',
	};

	let cleanedStdout = stdout;

	// Strip non-JSON text if option is enabled
	if (options.stripNonJson !== false) {
		const jsonMatch = stdout.match(/(\{[\s\S]*\}|\[[\s\S]*\])/);
		if (jsonMatch) {
			cleanedStdout = jsonMatch[1];
		}
	}

	try {
		if (options.multipleJson) {
			// Handle multiple JSON objects
			const lines = cleanedStdout.split('\n').filter(line => line.trim());
			const jsonObjects = [];
			
			for (const line of lines) {
				try {
					jsonObjects.push(JSON.parse(line.trim()));
				} catch {
					// Skip non-JSON lines
				}
			}
			
			result.parsed_stdout = jsonObjects.length === 1 ? jsonObjects[0] : jsonObjects;
		} else {
			// Single JSON object
			result.parsed_stdout = JSON.parse(cleanedStdout);
		}
		
		result.parsing_success = true;
	} catch (error) {
		result.parsing_error = (error as Error).message;
		if (options.fallbackOnError !== false) {
			result.parsed_stdout = stdout;
		}
	}

	return result;
}


function parseAsLines(stdout: string): ParseResult {
	return {
		parsed_stdout: stdout.split('\n'),
		parsing_success: true,
		parsing_error: null,
		output_format: 'lines',
		parsing_method: 'lines',
	};
}


function parseSmartMode(stdout: string, options: ParseOptions): ParseResult {
	const trimmed = stdout.trim();

	// Try JSON first
	if ((trimmed.startsWith('{') && trimmed.endsWith('}')) || 
		(trimmed.startsWith('[') && trimmed.endsWith(']'))) {
		const jsonResult = parseAsJson(stdout, options);
		if (jsonResult.parsing_success) {
			jsonResult.parsing_method = 'smart_json';
			return jsonResult;
		}
	}

	// Try CSV detection
	if (detectCSV(stdout)) {
		return parseAsCSV(stdout);
	}

	// Fallback to lines
	const linesResult = parseAsLines(stdout);
	linesResult.parsing_method = 'smart_lines';
	linesResult.output_format = 'text_lines';
	return linesResult;
}


function detectCSV(stdout: string): boolean {
	const lines = stdout.split('\n').filter(line => line.trim());
	if (lines.length < 2) return false;

	// Check if lines have consistent comma or tab separators
	const firstLineCommas = (lines[0].match(/,/g) || []).length;
	const firstLineTabs = (lines[0].match(/\t/g) || []).length;
	
	if (firstLineCommas === 0 && firstLineTabs === 0) return false;

	// Check consistency across lines
	return lines.slice(1, Math.min(5, lines.length)).every(line => {
		const commas = (line.match(/,/g) || []).length;
		const tabs = (line.match(/\t/g) || []).length;
		return commas === firstLineCommas || tabs === firstLineTabs;
	});
}


function parseAsCSV(stdout: string): ParseResult {
	const lines = stdout.split('\n').filter(line => line.trim());
	const delimiter = stdout.includes('\t') ? '\t' : ',';
	
	if (lines.length === 0) {
		return {
			parsed_stdout: [],
			parsing_success: true,
			parsing_error: null,
			output_format: 'csv',
			parsing_method: 'smart_csv',
		};
	}

	const headers = lines[0].split(delimiter).map(h => h.trim());
	const rows = lines.slice(1).map(line => {
		const values = line.split(delimiter).map(v => v.trim());
		const row: { [key: string]: string } = {};
		headers.forEach((header, index) => {
			row[header] = values[index] || '';
		});
		return row;
	});

	return {
		parsed_stdout: rows,
		parsing_success: true,
		parsing_error: null,
		output_format: 'csv',
		parsing_method: 'smart_csv',
	};
}


async function createDebugInfo(
	scriptPath: string,
	scriptContent: string,
	pythonPath: string,
	inputData?: IDataObject[],
	envVars?: Record<string, string>,
	timing?: DebugTiming,
	credentialSources?: Record<string, string>,
): Promise<DebugInfo> {
	const debugInfo: DebugInfo = {
		script_content: scriptContent,
		script_path: scriptPath,
		execution_command: [pythonPath, scriptPath],
		timing: timing || { script_created_at: new Date().toISOString() },
	};

	// Add injected data if provided
	if (inputData || envVars) {
		debugInfo.injected_data = {
			input_items: inputData || [],
			env_vars: envVars || {},
		};
	}

	// Check Python environment
	try {
		// Create a simple version check script
		const versionScript = 'import sys; print(sys.version)';
		const versionScriptPath = scriptPath.replace('.py', '_version_check.py');
		fs.writeFileSync(versionScriptPath, versionScript, { encoding: 'utf8' });
		
		const versionResult = await execPythonSpawn(versionScriptPath, pythonPath, process.cwd(), 1); // 1 minute timeout for version check
		
		// Clean up version check script
		try {
			fs.unlinkSync(versionScriptPath);
		} catch (e) {
			// Ignore cleanup errors
		}
		
		debugInfo.environment_check = {
			python_executable_found: versionResult.exitCode === 0,
			python_version_output: versionResult.stdout || versionResult.stderr,
			python_path_resolved: pythonPath,
		};
	} catch (error) {
		debugInfo.environment_check = {
			python_executable_found: false,
			python_path_resolved: pythonPath,
		};
	}

	// Validate Python syntax
	try {
		const syntaxValidation = await validatePythonSyntax(scriptPath, pythonPath);
		debugInfo.syntax_validation = syntaxValidation;
	} catch (error) {
		debugInfo.syntax_validation = {
			is_valid: false,
			syntax_error: (error as Error).message,
		};
	}

	return debugInfo;
}

async function validatePythonSyntax(scriptPath: string, pythonPath: string): Promise<{
	is_valid: boolean;
	syntax_error?: string;
	line_number?: number;
}> {
	try {
		// Use Python's compile() to check syntax without executing
		const validationScript = `
import ast
import sys

try:
    with open('${scriptPath.replace(/\\/g, '\\\\')}', 'r', encoding='utf-8') as f:
        source = f.read()
    
    # Try to parse the AST
    ast.parse(source)
    print("SYNTAX_VALID")
    
except SyntaxError as e:
    print(f"SYNTAX_ERROR:{e.msg}:LINE:{e.lineno}")
    sys.exit(1)
except Exception as e:
    print(f"VALIDATION_ERROR:{str(e)}")
    sys.exit(1)
`;

		const validationPath = scriptPath.replace('.py', '_validation.py');
		fs.writeFileSync(validationPath, validationScript, { encoding: 'utf8' });

		const result = await execPythonSpawn(validationPath, pythonPath, process.cwd(), 1); // 1 minute timeout for validation
		
		// Clean up validation script
		try {
			fs.unlinkSync(validationPath);
		} catch (e) {
			// Ignore cleanup errors
		}

		if (result.stdout.includes('SYNTAX_VALID')) {
			return { is_valid: true };
		} else if (result.stdout.includes('SYNTAX_ERROR:')) {
			const parts = result.stdout.split(':');
			return {
				is_valid: false,
				syntax_error: parts[1] || 'Unknown syntax error',
				line_number: parts[3] ? parseInt(parts[3], 10) : undefined,
			};
		} else {
			return {
				is_valid: false,
				syntax_error: result.stderr || result.stdout || 'Unknown validation error',
			};
		}
	} catch (error) {
		return {
			is_valid: false,
			syntax_error: (error as Error).message,
		};
	}
}

function createScriptBinary(scriptContent: string, filename = 'script.py', format = 'py'): { [key: string]: unknown } {
	// Determine file extension and MIME type based on format
	let fileExtension: string;
	let mimeType: string;
	let finalFilename: string;
	
	if (format === 'txt') {
		fileExtension = 'txt';
		mimeType = 'text/plain';
		// Replace .py extension with .txt
		finalFilename = filename.replace(/\.py$/, '.txt');
	} else {
		fileExtension = 'py';
		mimeType = 'text/x-python';
		finalFilename = filename;
	}
	
	const buffer = Buffer.from(scriptContent, 'utf8');
	return {
		[finalFilename]: {
			data: buffer.toString('base64'),
			mimeType,
			fileExtension,
			fileName: finalFilename,
		},
	};
}

function createOutputJsonBinary(outputData: IDataObject, filename = 'output.json'): { [key: string]: unknown } {
	// Create output.json file with the execution results
	// –£–±–∏—Ä–∞–µ–º script_content –∏–∑ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ —Ç–∞–∫ –∫–∞–∫ —Å–∫—Ä–∏–ø—Ç —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–µ—Ç—Å—è –æ—Ç–¥–µ–ª—å–Ω—ã–º —Ñ–∞–π–ª–æ–º
	const cleanedOutputData = { ...outputData };
	delete cleanedOutputData.script_content;
	
	const outputJsonContent = {
		timestamp: new Date().toISOString(),
		execution_results: cleanedOutputData,
		export_info: {
			description: "–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è Python —Å–∫—Ä–∏–ø—Ç–∞ –∏–∑ n8n",
			format_version: "1.0",
			exported_at: new Date().toISOString(),
			node_type: "n8n-nodes-python.pythonFunction"
		}
	};
	
	const jsonString = JSON.stringify(outputJsonContent, null, 2);
	const buffer = Buffer.from(jsonString, 'utf8');
	
	return {
		[filename]: {
			data: buffer.toString('base64'),
			mimeType: 'application/json',
			fileExtension: 'json',
			fileName: filename,
		},
	};
}

function createFullDebugPlusDiagnosticsBinary(
	diagnostics: FullDebugPlusDiagnostics, 
	executionResults: IDataObject, 
	filename = 'full_debug_plus_diagnostics.json'
): { [key: string]: unknown } {
	// Create comprehensive diagnostics file including execution results
	const cleanedExecutionResults = { ...executionResults };
	delete cleanedExecutionResults.script_content; // Script is exported separately
	delete cleanedExecutionResults.full_debug_plus_diagnostics; // Avoid duplication
	
	const fullDiagnosticsContent = {
		mode: 'full_debug_plus',
		timestamp: new Date().toISOString(),
		diagnostics: diagnostics,
		execution_results: cleanedExecutionResults,
		export_info: {
			description: "Full Debug+ comprehensive diagnostics and execution results from n8n Python Raw node",
			format_version: "1.0",
			exported_at: new Date().toISOString(),
			node_type: "n8n-nodes-python-raw.pythonFunctionRaw",
			package_version: diagnostics.node_installation?.package?.version || 'unknown',
		}
	};
	
	const jsonString = JSON.stringify(fullDiagnosticsContent, null, 2);
	const buffer = Buffer.from(jsonString, 'utf8');
	
	return {
		[filename]: {
			data: buffer.toString('base64'),
			mimeType: 'application/json',
			fileExtension: 'json',
			fileName: filename,
		},
	};
}

function addDebugInfoToResult(
	result: IDataObject,
	debugInfo: DebugInfo,
	debugMode: string,
	scriptContent?: string,
): void {
	if (debugMode === 'off') return;

	const debugData: IDataObject = {};

	if (['basic', 'full', 'test'].includes(debugMode)) {
		debugData.script_content = debugInfo.script_content;
		debugData.execution_command = debugInfo.execution_command.join(' ');
	}

	if (['export'].includes(debugMode)) {
		// –í —Ä–µ–∂–∏–º–µ —ç–∫—Å–ø–æ—Ä—Ç–∞ –Ω–µ –¥–æ–±–∞–≤–ª—è–µ–º script_content, —Ç–æ–ª—å–∫–æ execution_command
		debugData.execution_command = debugInfo.execution_command.join(' ');
	}

	if (['full', 'test', 'export'].includes(debugMode)) {
		debugData.debug_info = {
			package_version: getPackageVersion(),
			script_path: debugInfo.script_path,
				timing: debugInfo.timing,
				environment_check: debugInfo.environment_check,
				syntax_validation: debugInfo.syntax_validation,
		};

		if (debugInfo.injected_data) {
			(debugData.debug_info as IDataObject).injected_data = debugInfo.injected_data;
		}
	}

	if (['test'].includes(debugMode)) {
		debugData.test_mode = true;
		debugData.execution_skipped = true;
		debugData.validation_only = true;
	}

	Object.assign(result, debugData);
}

function handlePassThroughData(result: IDataObject, items: INodeExecutionData[], passThrough: boolean, passThroughMode: string): INodeExecutionData[] {
	if (!passThrough) {
		return [{ json: result }];
	}

	const resultWithPassThrough: INodeExecutionData[] = [];

	if (passThroughMode === 'multiple') {
		// First add the Python result
		resultWithPassThrough.push({ json: result });
		
		// Then add each input item
		for (const item of items) {
			resultWithPassThrough.push({
				json: item.json,
				binary: item.binary,
				pairedItem: item.pairedItem,
			});
		}
	} else {
		// For merge and separate modes, combine with each input item
		for (const item of items) {
			const combinedResult: IDataObject = { ...result };
			
			if (passThroughMode === 'merge') {
				// Merge input fields directly into result (input fields override if same names)
				Object.assign(combinedResult, item.json);
			} else if (passThroughMode === 'separate') {
				// Add input data as separate field
				combinedResult.inputData = item.json;
			}
			
			resultWithPassThrough.push({
				json: combinedResult,
				binary: item.binary,
				pairedItem: item.pairedItem,
			});
		}
	}

	return resultWithPassThrough;
}

// Output file processing functions
async function scanOutputDirectory(outputDir: string, options: OutputFileProcessingOptions): Promise<OutputFileInfo[]> {
	const outputFiles: OutputFileInfo[] = [];
	
	if (!fs.existsSync(outputDir)) {
		return outputFiles;
	}
	
	try {
		const files = fs.readdirSync(outputDir);
		console.log(`Found ${files.length} files in output directory: ${outputDir}`);
		
		for (const filename of files) {
			const filepath = path.join(outputDir, filename);
			const stats = fs.statSync(filepath);
			
			if (stats.isFile()) {
				// Validate file size
				const sizeInMB = stats.size / (1024 * 1024);
				if (sizeInMB > options.maxOutputFileSize) {
					console.warn(`Output file "${filename}" is too large: ${sizeInMB.toFixed(2)}MB > ${options.maxOutputFileSize}MB, skipping`);
					continue;
				}
				
				// Read file content and convert to base64
				const content = fs.readFileSync(filepath);
				const base64Data = content.toString('base64');
				
				// Get file info
				const extension = getFileExtension(filename);
				const mimetype = getMimeType(extension);
				const binaryKey = `output_${filename}`;
				
				const outputFile: OutputFileInfo = {
					filename,
					size: stats.size,
					mimetype,
					extension,
					base64Data,
					binaryKey,
				};
				
				outputFiles.push(outputFile);
				console.log(`Processed output file: ${filename} (${sizeInMB.toFixed(2)}MB, ${mimetype})`);
			}
		}
	} catch (error) {
		console.error(`Error scanning output directory ${outputDir}:`, error);
		throw new Error(`Failed to scan output directory: ${(error as Error).message}`);
	}
	
	return outputFiles;
}

function getMimeType(extension: string): string {
	const mimeTypes: Record<string, string> = {
		'txt': 'text/plain',
		'json': 'application/json',
		'csv': 'text/csv',
		'html': 'text/html',
		'xml': 'application/xml',
		'pdf': 'application/pdf',
		'doc': 'application/msword',
		'docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
		'xls': 'application/vnd.ms-excel',
		'xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
		'png': 'image/png',
		'jpg': 'image/jpeg',
		'jpeg': 'image/jpeg',
		'gif': 'image/gif',
		'svg': 'image/svg+xml',
		'mp4': 'video/mp4',
		'avi': 'video/x-msvideo',
		'mov': 'video/quicktime',
		'mp3': 'audio/mpeg',
		'wav': 'audio/wav',
		'zip': 'application/zip',
		'rar': 'application/x-rar-compressed',
		'tar': 'application/x-tar',
		'gz': 'application/gzip',
	};
	
	return mimeTypes[extension.toLowerCase()] || 'application/octet-stream';
}

async function cleanupOutputDirectory(outputDir: string): Promise<void> {
	if (!fs.existsSync(outputDir)) {
		return;
	}
	
	try {
		const files = fs.readdirSync(outputDir);
		let cleanedFiles = 0;
		
		for (const filename of files) {
			const filepath = path.join(outputDir, filename);
			try {
				fs.unlinkSync(filepath);
				cleanedFiles++;
			} catch (error) {
				console.warn(`Failed to delete output file ${filepath}:`, error);
			}
		}
		
		// Remove the directory itself
		fs.rmdirSync(outputDir);
		console.log(`Cleaned up output directory: ${outputDir} (${cleanedFiles} files removed)`);
	} catch (error) {
		console.warn(`Failed to cleanup output directory ${outputDir}:`, error);
		// Don't throw error - cleanup should not break main process
	}
}

function createUniqueOutputDirectory(): string {
	const timestamp = Date.now();
	const randomId = Math.random().toString(36).substring(2, 8);
	const uniqueId = `n8n_python_output_${timestamp}_${randomId}`;
	const outputDir = path.join(require('os').tmpdir(), uniqueId);
	
	fs.mkdirSync(outputDir, { recursive: true });
	console.log(`Created output directory: ${outputDir}`);
	
	return outputDir;
}

// File debugging functions
async function createFileDebugInfo(
	inputFiles: FileMapping[],
	outputDir?: string,
	outputFileProcessingOptions?: OutputFileProcessingOptions,
	options?: FileDebugOptions,
): Promise<FileDebugInfo> {
	const debugInfo: FileDebugInfo = {};
	
	if (!options?.enabled) {
		return debugInfo;
	}
	
	try {
		// Input files debug info
		if (options.includeInputFileDebug) {
			debugInfo.input_files = await createInputFileDebugInfo(inputFiles);
		}
		
		// Output files debug info
		if (options.includeOutputFileDebug && outputDir) {
			debugInfo.output_files = await createOutputFileDebugInfo(outputDir, outputFileProcessingOptions);
		}
		
		// System info
		if (options.includeSystemInfo) {
			debugInfo.system_info = await createSystemDebugInfo(outputDir);
		}
		
		// Directory listings
		if (options.includeDirectoryListing) {
			debugInfo.directory_listing = await createDirectoryListingInfo(outputDir);
		}
		
	} catch (error) {
		console.error('Error creating file debug info:', error);
		// Return partial debug info instead of failing completely
	}
	
	return debugInfo;
}

async function createInputFileDebugInfo(inputFiles: FileMapping[]): Promise<FileDebugInfo['input_files']> {
	const processingErrors: string[] = [];
	let totalSizeMB = 0;
	const filesByType: Record<string, number> = {};
	const filesDetails: Array<{
		filename: string;
		size_mb: number;
		mimetype: string;
		extension: string;
		binary_key: string;
		item_index: number;
		temp_path?: string;
		base64_available: boolean;
	}> = [];
	
	for (const file of inputFiles) {
		try {
			const sizeMB = file.size / (1024 * 1024);
			totalSizeMB += sizeMB;
			
			// Count by type
			const typeKey = file.mimetype || 'unknown';
			filesByType[typeKey] = (filesByType[typeKey] || 0) + 1;
			
			// File details
			filesDetails.push({
				filename: file.filename,
				size_mb: Math.round(sizeMB * 100) / 100,
				mimetype: file.mimetype,
				extension: file.extension,
				binary_key: file.binaryKey,
				item_index: file.itemIndex,
				temp_path: file.tempPath,
				base64_available: !!file.base64Data,
			});
			
		} catch (error) {
			processingErrors.push(`Error processing file ${file.filename}: ${(error as Error).message}`);
		}
	}
	
	return {
		count: inputFiles.length,
		total_size_mb: Math.round(totalSizeMB * 100) / 100,
		files_by_type: filesByType,
		files_details: filesDetails,
		processing_errors: processingErrors.length > 0 ? processingErrors : undefined,
	};
}

async function createOutputFileDebugInfo(
	outputDir: string,
	options?: OutputFileProcessingOptions,
): Promise<FileDebugInfo['output_files']> {
	const scanErrors: string[] = [];
	const foundFiles: Array<{
		filename: string;
		size_mb: number;
		mimetype: string;
		extension: string;
		full_path: string;
		created_at: string;
	}> = [];
	let directoryExists = false;
	let directoryWritable = false;
	let directoryPermissions: string | undefined;
	
	try {
		// Check if directory exists
		directoryExists = fs.existsSync(outputDir);
		
		if (directoryExists) {
			// Check permissions
			try {
				await fs.promises.access(outputDir, fs.constants.W_OK);
				directoryWritable = true;
			} catch {
				directoryWritable = false;
			}
			
			// Get permissions
			try {
				const stats = await fs.promises.stat(outputDir);
				directoryPermissions = stats.mode.toString(8);
			} catch (error) {
				scanErrors.push(`Could not read directory permissions: ${(error as Error).message}`);
			}
			
			// Scan for files
			try {
				const files = await fs.promises.readdir(outputDir);
				for (const file of files) {
					try {
						const filePath = path.join(outputDir, file);
						const stats = await fs.promises.stat(filePath);
						
						if (stats.isFile()) {
							const extension = getFileExtension(file);
							const sizeMB = stats.size / (1024 * 1024);
							
							foundFiles.push({
								filename: file,
								size_mb: Math.round(sizeMB * 100) / 100,
								mimetype: getMimeType(extension),
								extension,
								full_path: filePath,
								created_at: stats.birthtime.toISOString(),
							});
						}
					} catch (error) {
						scanErrors.push(`Error scanning file ${file}: ${(error as Error).message}`);
					}
				}
			} catch (error) {
				scanErrors.push(`Could not read directory contents: ${(error as Error).message}`);
			}
		}
		
	} catch (error) {
		scanErrors.push(`Directory access error: ${(error as Error).message}`);
	}
	
	return {
		processing_enabled: options?.enabled === true,
		output_directory: outputDir,
		directory_exists: directoryExists,
		directory_writable: directoryWritable,
		directory_permissions: directoryPermissions,
		found_files: foundFiles,
		scan_errors: scanErrors.length > 0 ? scanErrors : undefined,
	};
}

async function createSystemDebugInfo(outputDir?: string): Promise<FileDebugInfo['system_info']> {
	const systemInfo: FileDebugInfo['system_info'] = {
		python_executable: '',
		working_directory: process.cwd(),
		user_permissions: {
			can_write_temp: false,
			can_create_files: false,
		},
		disk_space: {},
		environment_variables: {
			output_dir_available: false,
		},
	};
	
	// Check temp directory write permissions
	try {
		const tempFile = tempy.file();
		await fs.promises.writeFile(tempFile, 'test');
		await fs.promises.unlink(tempFile);
		systemInfo.user_permissions.can_write_temp = true;
	} catch {
		systemInfo.user_permissions.can_write_temp = false;
	}
	
	// Check file creation permissions in current directory
	try {
		const testFile = path.join(process.cwd(), `test_${Date.now()}.tmp`);
		await fs.promises.writeFile(testFile, 'test');
		await fs.promises.unlink(testFile);
		systemInfo.user_permissions.can_create_files = true;
	} catch {
		systemInfo.user_permissions.can_create_files = false;
	}
	
	// Check environment variables
	if (outputDir) {
		systemInfo.environment_variables.output_dir_available = true;
		systemInfo.environment_variables.output_dir_value = outputDir;
	}
	
	// Get temp directory info
	systemInfo.disk_space.temp_dir = tempy.directory();
	
	return systemInfo;
}

async function createDirectoryListingInfo(outputDir?: string): Promise<FileDebugInfo['directory_listing']> {
	const listing: FileDebugInfo['directory_listing'] = {};
	
	try {
		// List working directory
		listing.working_directory = fs.readdirSync(process.cwd());
	} catch (error) {
		listing.working_directory = [`Error reading working directory: ${(error as Error).message}`];
	}
	
	if (outputDir) {
		try {
			// List output directory
			if (fs.existsSync(outputDir)) {
				listing.output_directory = fs.readdirSync(outputDir);
			} else {
				listing.output_directory = ['Directory does not exist'];
			}
		} catch (error) {
			listing.output_directory = [`Error reading output directory: ${(error as Error).message}`];
		}
	}
	
	try {
		// List temp directory
		const tempDir = tempy.directory();
		listing.temp_directory = fs.readdirSync(tempDir);
	} catch (error) {
		listing.temp_directory = [`Error reading temp directory: ${(error as Error).message}`];
	}
	
	return listing;
}

// Auto-search for files by name across filesystem
async function searchForFileByName(fileName: string, searchPaths?: string[]): Promise<OutputFileInfo[]> {
	const foundFiles: OutputFileInfo[] = [];
	const searchDirectories = searchPaths || [process.cwd(), '/tmp', '/var/tmp'];

	for (const searchPath of searchDirectories) {
		if (!fs.existsSync(searchPath)) continue;

		try {
			const searchInDirectory = async (dirPath: string, maxDepth = 3): Promise<void> => {
				if (maxDepth <= 0) return;

				const entries = await fs.promises.readdir(dirPath, { withFileTypes: true });
				for (const entry of entries) {
					const fullPath = path.join(dirPath, entry.name);

					if (entry.isFile() && entry.name === fileName) {
						try {
							const stats = await fs.promises.stat(fullPath);
							const content = await fs.promises.readFile(fullPath);
							const extension = getFileExtension(fileName);

							foundFiles.push({
								filename: fileName,
								size: stats.size,
								mimetype: getMimeType(extension),
								extension,
								base64Data: content.toString('base64'),
								binaryKey: `found_${fileName.replace(/[^a-zA-Z0-9]/g, '_')}`,
							});
						} catch (error) {
							console.warn(`Failed to read found file ${fullPath}:`, error);
						}
					} else if (entry.isDirectory() && !entry.name.startsWith('.')) {
						await searchInDirectory(fullPath, maxDepth - 1);
					}
				}
			};

			await searchInDirectory(searchPath);
		} catch (error) {
			console.warn(`Failed to search in directory ${searchPath}:`, error);
		}
	}

	return foundFiles;
}

// Helper function to generate code template for Extract Code Template functionality
function generateCodeTemplateStatic(
	functionCode = '',
	includeInputItems = true,
	includeEnvVarsDict = false,
	hideVariableValues = true,
	includeFiles = false,
	includeOutputDir = false,
): string {
	try {
		// Mock data for template generation
		const mockData: IDataObject[] = [
			{ id: 1, name: 'Sample Item 1', status: 'active' },
			{ id: 2, name: 'Sample Item 2', status: 'pending' },
		];
		
		const mockEnvVars: Record<string, string> = {
			API_KEY: hideVariableValues ? '***HIDDEN***' : 'your_api_key_here',
			DATABASE_URL: hideVariableValues ? '***HIDDEN***' : 'postgresql://user:pass@host:5432/db',
			DEBUG: 'true',
			PORT: '3000',
		};

		const mockCredentialSources: Record<string, string> = {
			API_KEY: 'main_credential',
			DATABASE_URL: 'main_credential',
			DEBUG: 'main_credential',
			PORT: 'main_credential',
		};

		const mockInputFiles: FileMapping[] = includeFiles ? [
			{
				filename: 'example.txt',
				mimetype: 'text/plain',
				size: 1024,
				binaryKey: 'example_txt',
				itemIndex: 0,
				extension: 'txt',
				tempPath: '/tmp/example.txt',
				base64Data: 'ZXhhbXBsZSBjb250ZW50',
			},
		] : [];

		const outputDir = includeOutputDir ? '/tmp/n8n_output_YYYYMMDD_HHMMSS_random' : undefined;

		// Generate the full script
		const fullScript = getScriptCode(
			functionCode,
			mockData,
			mockEnvVars,
			includeInputItems,
			includeEnvVarsDict,
			hideVariableValues,
			mockCredentialSources,
			mockInputFiles,
			outputDir,
		);

		// Extract only the auto-generated part (everything before user code)
		if (functionCode && functionCode.trim()) {
			const userCodeStart = fullScript.indexOf(functionCode);
			if (userCodeStart > 0) {
				return fullScript.substring(0, userCodeStart).trim();
			}
		}

		// If no user code or user code not found, return the full script
		return fullScript;

	} catch (error) {
		console.error('Error generating code template:', error);
		return `# Error generating template: ${(error as Error).message}\n# Please check your node configuration`;
	}
}

// Export the function for testing purposes
export { generateCodeTemplateStatic };


